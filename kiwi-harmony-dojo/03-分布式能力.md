# 鸿蒙分布式能力

## 💡 核心结论

1. **分布式是鸿蒙的核心特色，实现多设备协同**
2. **分布式数据管理让多设备数据同步**
3. **分布式任务调度可以跨设备运行应用**
4. **分布式硬件虚拟化让设备能力共享**
5. **超级终端让多设备成为一个整体**

---

## 1. 分布式数据管理

### 1.1 分布式对象

```typescript
import distributedObject from '@ohos.data.distributedDataObject'

@Entry
@Component
struct DistributedDataDemo {
  private distributedObj: distributedObject.DataObject

  aboutToAppear() {
    // 创建分布式对象
    this.distributedObj = distributedObject.create(this.getContext(), {
      name: '张三',
      age: 25,
      score: 100
    })
    
    // 设置session ID（同一ID的设备会同步数据）
    this.distributedObj.setSessionId('session_001')
    
    // 监听数据变化
    this.distributedObj.on('change', (sessionId, fields) => {
      console.log('数据变化:', fields)
      console.log('name:', this.distributedObj['name'])
    })
  }
  
  updateData() {
    // 修改数据会自动同步到其他设备
    this.distributedObj['score'] = 200
  }

  build() {
    Column() {
      Text(`姓名: ${this.distributedObj['name']}`)
      Text(`分数: ${this.distributedObj['score']}`)
      
      Button('增加分数')
        .onClick(() => {
          this.updateData()
        })
    }
  }
}
```

### 1.2 分布式键值数据库

```typescript
import distributedKVStore from '@ohos.data.distributedKVStore'

class DataManager {
  private kvStore: distributedKVStore.SingleKVStore

  async init() {
    const kvManager = distributedKVStore.createKVManager({
      bundleName: 'com.example.myapp'
    })
    
    // 创建分布式KV数据库
    const options: distributedKVStore.Options = {
      createIfMissing: true,
      encrypt: false,
      backup: false,
      autoSync: true,  // 自动同步
      kvStoreType: distributedKVStore.KVStoreType.SINGLE_VERSION
    }
    
    this.kvStore = await kvManager.getKVStore('mystore', options)
    
    // 监听同步完成
    this.kvStore.on('syncComplete', (data) => {
      console.log('同步完成:', data)
    })
  }
  
  async put(key: string, value: string) {
    await this.kvStore.put(key, value)
  }
  
  async get(key: string): Promise<string> {
    return await this.kvStore.get(key) as string
  }
  
  async sync(deviceIds: string[]) {
    // 手动触发同步
    this.kvStore.sync(deviceIds, distributedKVStore.SyncMode.PUSH_PULL)
  }
}
```

---

## 2. 分布式任务调度

### 2.1 跨设备启动Ability

```typescript
import featureAbility from '@ohos.ability.featureAbility'

@Entry
@Component
struct DistributedAbilityDemo {
  async startRemoteAbility() {
    try {
      // 获取在线设备列表
      const deviceManager = await distributedDeviceManager.createDeviceManager('com.example.myapp')
      const devices = deviceManager.getTrustedDeviceListSync()
      
      if (devices.length > 0) {
        const targetDevice = devices[0]
        
        // 启动远程Ability
        await featureAbility.startAbility({
          deviceId: targetDevice.deviceId,  // 目标设备ID
          bundleName: 'com.example.myapp',
          abilityName: 'EntryAbility',
          parameters: {
            message: 'Hello from remote device'
          }
        })
        
        console.log('成功启动远程Ability')
      }
    } catch (error) {
      console.error('启动失败:', error)
    }
  }

  build() {
    Column() {
      Button('在其他设备打开')
        .onClick(() => {
          this.startRemoteAbility()
        })
    }
  }
}
```

### 2.2 分布式流转

```typescript
import UIAbility from '@ohos.app.ability.UIAbility'

export default class EntryAbility extends UIAbility {
  onContinue(wantParam) {
    // 准备要迁移的数据
    wantParam['data'] = {
      currentPage: 'Detail',
      scrollPosition: 100,
      userId: 123
    }
    
    return hilog.isLoggable(0x0000, 'testTag', hilog.LogLevel.INFO)
      ? AbilityConstant.OnContinueResult.AGREE
      : AbilityConstant.OnContinueResult.REJECT
  }

  onCreate(want, launchParam) {
    // 从迁移恢复数据
    if (launchParam.launchReason === AbilityConstant.LaunchReason.CONTINUATION) {
      const data = want.parameters.data
      console.log('恢复数据:', data)
      // 恢复应用状态
    }
  }
}
```

---

## 3. 分布式硬件虚拟化

### 3.1 相机调用

```typescript
import camera from '@ohos.multimedia.camera'

@Entry
@Component
struct DistributedCameraDemo {
  async useRemoteCamera() {
    try {
      // 获取相机管理器
      const cameraManager = camera.getCameraManager(this.getContext())
      
      // 获取所有相机（包括远程设备的）
      const cameras = cameraManager.getSupportedCameras()
      
      // 选择远程设备的相机
      const remoteCamera = cameras.find(cam => cam.connectionType === camera.ConnectionType.REMOTE)
      
      if (remoteCamera) {
        // 使用远程相机
        const cameraInput = cameraManager.createCameraInput(remoteCamera)
        console.log('使用远程相机:', remoteCamera.deviceId)
      }
    } catch (error) {
      console.error('相机调用失败:', error)
    }
  }

  build() {
    Column() {
      Button('使用其他设备的相机')
        .onClick(() => {
          this.useRemoteCamera()
        })
    }
  }
}
```

---

## 4. 常见问题

### Q1: 如何调试分布式应用？
**A**: 需要两台鸿蒙设备，或使用模拟器+真机组合

### Q2: 分布式数据如何保证安全？
**A**: 数据传输加密，设备需要配对信任

### Q3: 如何获取设备列表？
**A**: 使用DeviceManager API获取可信设备列表

---

## 参考资源

- 分布式开发指南
- 分布式数据管理
- 分布式任务调度

