# 网络与数据持久化

## 💡 核心结论

1. **@ohos.net.http提供HTTP网络请求能力**
2. **Preferences适合键值对存储**
3. **关系型数据库适合复杂数据存储**
4. **文件管理使用@ohos.file.fs**
5. **网络请求需要配置权限**

---

## 1. 网络请求

### 1.1 HTTP请求

```typescript
import http from '@ohos.net.http'

class HttpUtil {
  static async get(url: string): Promise<any> {
    const httpRequest = http.createHttp()
    
    try {
      const response = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        header: {
          'Content-Type': 'application/json'
        },
        readTimeout: 10000,
        connectTimeout: 10000
      })
      
      if (response.responseCode === 200) {
        return JSON.parse(response.result as string)
      } else {
        throw new Error(`HTTP Error: ${response.responseCode}`)
      }
    } finally {
      httpRequest.destroy()
    }
  }
  
  static async post(url: string, data: object): Promise<any> {
    const httpRequest = http.createHttp()
    
    try {
      const response = await httpRequest.request(url, {
        method: http.RequestMethod.POST,
        header: {
          'Content-Type': 'application/json'
        },
        extraData: JSON.stringify(data)
      })
      
      return JSON.parse(response.result as string)
    } finally {
      httpRequest.destroy()
    }
  }
}

// 使用
@Entry
@Component
struct NetworkDemo {
  @State data: string = ''

  async loadData() {
    try {
      const result = await HttpUtil.get('https://api.example.com/data')
      this.data = JSON.stringify(result)
    } catch (error) {
      console.error('请求失败:', error)
    }
  }

  build() {
    Column() {
      Button('加载数据')
        .onClick(() => {
          this.loadData()
        })
      
      Text(this.data)
        .margin({ top: 20 })
    }
  }
}
```

---

## 2. 数据持久化

### 2.1 Preferences（首选项）

```typescript
import preferences from '@ohos.data.preferences'

class StorageUtil {
  private static pref: preferences.Preferences
  
  static async init(context) {
    this.pref = await preferences.getPreferences(context, 'mystore')
  }
  
  static async put(key: string, value: string | number | boolean) {
    await this.pref.put(key, value)
    await this.pref.flush()  // 持久化
  }
  
  static async get(key: string, defaultValue: any): Promise<any> {
    return await this.pref.get(key, defaultValue)
  }
  
  static async remove(key: string) {
    await this.pref.delete(key)
    await this.pref.flush()
  }
  
  static async clear() {
    await this.pref.clear()
    await this.pref.flush()
  }
}

// 使用
@Entry
@Component
struct StorageDemo {
  @State username: string = ''

  async aboutToAppear() {
    await StorageUtil.init(this.getContext())
    this.username = await StorageUtil.get('username', '') as string
  }

  async saveUsername() {
    await StorageUtil.put('username', this.username)
  }

  build() {
    Column() {
      TextInput({ text: this.username })
        .onChange((value) => {
          this.username = value
        })
      
      Button('保存')
        .onClick(() => {
          this.saveUsername()
        })
    }
  }
}
```

### 2.2 关系型数据库

```typescript
import relationalStore from '@ohos.data.relationalStore'

class DatabaseUtil {
  private static store: relationalStore.RdbStore
  
  static async init(context) {
    const config: relationalStore.StoreConfig = {
      name: 'mydb.db',
      securityLevel: relationalStore.SecurityLevel.S1
    }
    
    this.store = await relationalStore.getRdbStore(context, config)
    
    // 创建表
    const sql = `
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        age INTEGER,
        email TEXT
      )
    `
    await this.store.executeSql(sql)
  }
  
  static async insert(name: string, age: number, email: string) {
    const valueBucket = {
      'name': name,
      'age': age,
      'email': email
    }
    
    const rowId = await this.store.insert('users', valueBucket)
    return rowId
  }
  
  static async query(): Promise<any[]> {
    const predicates = new relationalStore.RdbPredicates('users')
    const resultSet = await this.store.query(predicates)
    
    const users = []
    while (resultSet.goToNextRow()) {
      users.push({
        id: resultSet.getLong(resultSet.getColumnIndex('id')),
        name: resultSet.getString(resultSet.getColumnIndex('name')),
        age: resultSet.getLong(resultSet.getColumnIndex('age')),
        email: resultSet.getString(resultSet.getColumnIndex('email'))
      })
    }
    
    resultSet.close()
    return users
  }
  
  static async update(id: number, name: string) {
    const valueBucket = { 'name': name }
    const predicates = new relationalStore.RdbPredicates('users')
    predicates.equalTo('id', id)
    
    const rows = await this.store.update(valueBucket, predicates)
    return rows
  }
  
  static async delete(id: number) {
    const predicates = new relationalStore.RdbPredicates('users')
    predicates.equalTo('id', id)
    
    const rows = await this.store.delete(predicates)
    return rows
  }
}
```

---

## 3. 文件操作

```typescript
import fs from '@ohos.file.fs'

class FileUtil {
  static async writeFile(path: string, content: string) {
    try {
      const file = fs.openSync(path, fs.OpenMode.CREATE | fs.OpenMode.WRITE_ONLY)
      fs.writeSync(file.fd, content)
      fs.closeSync(file)
      console.log('文件写入成功')
    } catch (error) {
      console.error('文件写入失败:', error)
    }
  }
  
  static async readFile(path: string): Promise<string> {
    try {
      const file = fs.openSync(path, fs.OpenMode.READ_ONLY)
      const buffer = new ArrayBuffer(4096)
      const readLen = fs.readSync(file.fd, buffer)
      fs.closeSync(file)
      
      const decoder = new util.TextDecoder('utf-8')
      return decoder.decode(new Uint8Array(buffer.slice(0, readLen)))
    } catch (error) {
      console.error('文件读取失败:', error)
      return ''
    }
  }
}
```

---

## 参考资源

- 分布式数据管理开发指南
- 数据持久化开发
- 文件管理开发

