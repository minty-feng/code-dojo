# 🍌 算法核心

算法是解决问题的方法和步骤，本模块提供Python和C++双语言实现，涵盖经典算法和常用技巧。

## 💡 核心理念

### 算法学习的本质
- **目标**：在给定约束下（时间、空间）找到最优解决方案
- **关键**：理解问题本质 → 选择合适算法 → 分析复杂度 → 优化实现
- **重点**：时间复杂度 > 空间复杂度 > 代码简洁性
- **实践**：理论 + 刷题 + 总结 = 掌握

### 复杂度速查
| 复杂度 | 10 | 100 | 1000 | 10^6 | 10^9 |
|--------|----|----|------|------|------|
| O(1) | ✅ | ✅ | ✅ | ✅ | ✅ |
| O(log n) | ✅ | ✅ | ✅ | ✅ | ✅ |
| O(n) | ✅ | ✅ | ✅ | ✅ | ⚠️ |
| O(n log n) | ✅ | ✅ | ✅ | ✅ | ❌ |
| O(n²) | ✅ | ✅ | ⚠️ | ❌ | ❌ |
| O(2^n) | ✅ | ❌ | ❌ | ❌ | ❌ |

## 📚 学习路径

### 第一阶段：基础算法（2020.03 - 2020.04）
1. **排序算法**：冒泡、选择、插入、归并、快排、堆排序
2. **搜索算法**：二分查找、DFS、BFS
3. **双指针技巧**：对撞指针、快慢指针、滑动窗口

### 第二阶段：核心思想（2020.04 - 2020.05）
4. **递归与回溯**：全排列、组合、N皇后
5. **分治算法**：归并排序、快速排序、二分查找
6. **贪心算法**：区间调度、哈夫曼编码、最小生成树

### 第三阶段：动态规划（2020.05 - 2020.06）
7. **动态规划基础**：斐波那契、爬楼梯、打家劫舍
8. **背包问题**：0-1背包、完全背包、多重背包
9. **DP进阶**：最长子序列、编辑距离、股票问题

## 🎯 目录结构

```
banana-algo-core/
├── README.md
├── 01-排序算法/
│   ├── README.md
│   ├── sorting.py
│   └── sorting.cpp
├── 02-搜索算法/
│   ├── README.md
│   ├── binary_search.py
│   ├── binary_search.cpp
│   ├── dfs_bfs.py
│   └── dfs_bfs.cpp
├── 03-双指针技巧/
│   ├── README.md
│   ├── two_pointers.py
│   └── two_pointers.cpp
├── 04-递归与回溯/
│   ├── README.md
│   ├── backtracking.py
│   └── backtracking.cpp
├── 05-分治算法/
│   ├── README.md
│   ├── divide_conquer.py
│   └── divide_conquer.cpp
├── 06-贪心算法/
│   ├── README.md
│   ├── greedy.py
│   └── greedy.cpp
├── 07-动态规划基础/
│   ├── README.md
│   ├── dp_basic.py
│   └── dp_basic.cpp
├── 08-背包问题/
│   ├── README.md
│   ├── knapsack.py
│   └── knapsack.cpp
└── 09-DP进阶/
    ├── README.md
    ├── dp_advanced.py
    └── dp_advanced.cpp
```

## 📊 算法分类

### 按策略分类
- **暴力法**：枚举所有可能
- **分治法**：分解→递归→合并
- **贪心法**：局部最优→全局最优
- **动态规划**：子问题重叠→记忆化
- **回溯法**：试探→回退→剪枝

### 按应用分类
- **排序**：快排、归并、堆排序
- **搜索**：二分、DFS、BFS
- **图算法**：最短路径、最小生成树
- **字符串**：KMP、字典树、后缀数组
- **数学**：素数、GCD、快速幂

## 🔧 环境要求

### Python
```bash
Python 3.8+
# 运行
python sorting.py
```

### C++
```bash
C++11+
# 编译运行
g++ -std=c++11 sorting.cpp -o sorting && ./sorting
```

## 💡 学习建议

### 刷题平台
- **LeetCode**：算法题库最全
- **牛客网**：校招题目
- **Codeforces**：竞赛训练
- **AtCoder**：日本竞赛平台

### 学习方法
1. **理解原理**：为什么这样做？
2. **手写代码**：不要复制粘贴
3. **分析复杂度**：时间和空间
4. **总结模板**：归纳解题套路
5. **定期复习**：遗忘曲线

### 刷题策略
```
第一遍：看题解，理解思路
第二遍：自己实现，对比差距
第三遍：优化代码，分析复杂度
第N遍：定期复习，形成肌肉记忆
```

## 📈 难度递进

### 入门（Easy）
- 数组、字符串、简单数学
- 模拟、排序、查找
- 基础数据结构应用

### 进阶（Medium）
- 二分查找变种
- DFS/BFS
- 动态规划入门
- 贪心算法

### 高级（Hard）
- 复杂DP
- 图算法
- 高级数据结构
- 数学证明

## 🎯 算法复杂度

### 常见排序算法
| 算法 | 平均 | 最坏 | 空间 | 稳定性 |
|------|------|------|------|--------|
| 冒泡 | O(n²) | O(n²) | O(1) | ✅ |
| 选择 | O(n²) | O(n²) | O(1) | ❌ |
| 插入 | O(n²) | O(n²) | O(1) | ✅ |
| 归并 | O(n log n) | O(n log n) | O(n) | ✅ |
| 快排 | O(n log n) | O(n²) | O(log n) | ❌ |
| 堆排序 | O(n log n) | O(n log n) | O(1) | ❌ |

### 查找算法
| 算法 | 前提 | 复杂度 |
|------|------|--------|
| 线性查找 | 无 | O(n) |
| 二分查找 | 有序 | O(log n) |
| 哈希查找 | 哈希表 | O(1) |
| BST查找 | BST | O(log n) |

## 🏆 目标成就

### 初级目标
- [ ] 掌握10种排序算法
- [ ] 熟练二分查找及变种
- [ ] 理解DFS和BFS
- [ ] 刷100道Easy题

### 中级目标
- [ ] 掌握动态规划基本套路
- [ ] 理解贪心算法证明
- [ ] 熟悉常见数据结构应用
- [ ] 刷100道Medium题

### 高级目标
- [ ] 独立解决Hard题
- [ ] 参加算法竞赛
- [ ] 理解高级算法
- [ ] 能够进行算法分析和优化

## 📚 参考资料

### 书籍
- 《算法导论》- 理论基础
- 《算法4》- 工程实践
- 《剑指Offer》- 面试准备
- 《编程珠玑》- 思维训练

### 在线资源
- [LeetCode](https://leetcode.com/)
- [算法可视化](https://visualgo.net/)
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)

## 🌟 总结

算法是程序员的内功，数据结构是招式。掌握算法需要：
1. 理解核心思想（分治、贪心、DP等）
2. 大量练习（至少300题）
3. 总结模板（形成肌肉记忆）
4. 持续复习（对抗遗忘）

从排序算法开始，逐步深入到动态规划，每个阶段都要：
- 理解原理
- 手写实现
- 分析复杂度
- 刷相关题目
- 总结套路

坚持下去，你一定能掌握算法的精髓！💪
