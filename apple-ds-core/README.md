# 🍎 数据结构核心

数据结构是程序设计的基础，本模块提供Python和C++双语言实现，从基础到高级逐步深入。

## 🎯 学习目标

### 核心能力
- **线性结构**：数组、链表、栈、队列
- **树形结构**：二叉树、二叉搜索树、AVL树、红黑树
- **哈希结构**：哈希表、哈希函数、冲突解决
- **图结构**：图的表示、遍历、最短路径
- **高级结构**：堆、并查集、线段树、字典树

### 技术深度
- **时间复杂度**：理解和分析算法效率
- **空间复杂度**：内存使用优化
- **应用场景**：实际问题建模
- **性能优化**：数据结构选择和调优

## 📚 学习路径

### 第一阶段：线性结构（2019.01 - 2019.03）
1. **数组与动态数组**：基础操作、动态扩容
2. **链表**：单链表、双链表、循环链表
3. **栈**：数组栈、链式栈、应用
4. **队列**：循环队列、链式队列、双端队列

### 第二阶段：哈希与树（2019.04 - 2019.08）
5. **哈希表**：哈希函数、冲突解决、性能分析
6. **二叉树**：遍历、构建、应用
7. **二叉搜索树**：查找、插入、删除
8. **堆**：最大堆、最小堆、优先队列

### 第三阶段：平衡树（2019.09 - 2020.03）
9. **AVL树**：平衡因子、旋转、自平衡
10. **红黑树**：性质、插入、删除、应用

## 🎨 目录结构

```
apple-ds-core/
├── README.md
├── 01-数组与链表/
│   ├── README.md
│   ├── array.py
│   ├── array.cpp
│   ├── linked_list.py
│   └── linked_list.cpp
├── 02-栈与队列/
│   ├── README.md
│   ├── stack.py
│   ├── stack.cpp
│   ├── queue.py
│   └── queue.cpp
├── 03-哈希表/
│   ├── README.md
│   ├── hash_table.py
│   └── hash_table.cpp
├── 04-二叉树/
│   ├── README.md
│   ├── binary_tree.py
│   └── binary_tree.cpp
├── 05-二叉搜索树/
│   ├── README.md
│   ├── bst.py
│   └── bst.cpp
├── 06-堆/
│   ├── README.md
│   ├── heap.py
│   └── heap.cpp
├── 07-AVL树/
│   ├── README.md
│   ├── avl_tree.py
│   └── avl_tree.cpp
└── 08-红黑树/
    ├── README.md
    ├── rb_tree.py
    └── rb_tree.cpp
```

## 🔧 环境要求

### Python
- Python 3.8+
- 标准库

### C++
- C++11或更高
- GCC 7+ / Clang 5+ / MSVC 2017+

## 🚀 快速开始

### Python
```bash
# 运行示例
python array.py
python linked_list.py

# 运行测试
python -m pytest tests/
```

### C++
```bash
# 编译
g++ -std=c++11 array.cpp -o array
g++ -std=c++11 linked_list.cpp -o linked_list

# 运行
./array
./linked_list
```

## 📊 复杂度对比

| 数据结构 | 查找 | 插入 | 删除 | 空间 |
|---------|------|------|------|------|
| 数组 | O(1) | O(n) | O(n) | O(n) |
| 链表 | O(n) | O(1) | O(1) | O(n) |
| 栈 | O(n) | O(1) | O(1) | O(n) |
| 队列 | O(n) | O(1) | O(1) | O(n) |
| 哈希表 | O(1) | O(1) | O(1) | O(n) |
| 二叉搜索树 | O(logn) | O(logn) | O(logn) | O(n) |
| AVL树 | O(logn) | O(logn) | O(logn) | O(n) |
| 红黑树 | O(logn) | O(logn) | O(logn) | O(n) |
| 堆 | O(n) | O(logn) | O(logn) | O(n) |

## 💡 学习建议

### 学习方法
1. **理论结合实践**：先理解原理，再看代码实现
2. **对比学习**：Python和C++实现对比
3. **画图辅助**：画出数据结构的状态变化
4. **刷题巩固**：在LeetCode上练习相关题目

### 推荐顺序
1. 先学Python实现（语法简洁，易于理解）
2. 再学C++实现（理解内存管理和指针）
3. 对比两种语言的实现差异
4. 分析时间和空间复杂度

## 🎯 应用场景

### 数组
- 顺序存储
- 随机访问
- 矩阵运算

### 链表
- 动态内存管理
- 频繁插入删除
- LRU缓存

### 栈
- 函数调用
- 表达式求值
- 括号匹配

### 队列
- 任务调度
- 广度优先搜索
- 消息队列

### 哈希表
- 快速查找
- 去重
- 缓存

### 二叉搜索树
- 有序数据维护
- 范围查询
- 数据库索引

### AVL树
- 严格平衡
- 查询密集型场景

### 红黑树
- C++ STL (map, set)
- Java TreeMap
- Linux内核

### 堆
- 优先队列
- Top K问题
- 堆排序

## 📚 参考资料

- 《算法导论》
- 《数据结构与算法分析》
- [LeetCode](https://leetcode.com/)
- [VisuAlgo](https://visualgo.net/)

## 🌟 总结

数据结构是编程的基石，选择合适的数据结构能大幅提升程序效率。通过Python和C++双语言学习，既能理解高层抽象，又能掌握底层实现细节。

建议循序渐进，从简单的线性结构开始，逐步过渡到复杂的树形结构，最后掌握高级的平衡树。每学习一个数据结构，都要：
1. 理解其原理和特性
2. 掌握基本操作的实现
3. 分析时间和空间复杂度
4. 了解实际应用场景
5. 练习相关算法题目
