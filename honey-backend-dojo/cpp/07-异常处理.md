# 07-异常处理

## 异常基础

### 异常抛出
```cpp
#include <stdexcept>

// 抛出标准异常
void divide(int a, int b) {
    if (b == 0) {
        throw std::invalid_argument("Division by zero");
    }
    return a / b;
}

// 抛出自定义异常
class CustomException : public std::exception {
private:
    std::string message;
public:
    CustomException(const std::string& msg) : message(msg) {}
    const char* what() const noexcept override {
        return message.c_str();
    }
};

void riskyFunction() {
    throw CustomException("Something went wrong");
}
```

### 异常捕获
```cpp
try {
    divide(10, 0);
} catch (const std::invalid_argument& e) {
    std::cout << "Invalid argument: " << e.what() << std::endl;
} catch (const std::exception& e) {
    std::cout << "Standard exception: " << e.what() << std::endl;
} catch (...) {
    std::cout << "Unknown exception caught" << std::endl;
}
```

### 异常规范
```cpp
// C++11之前的异常规范（已废弃）
void oldFunction() throw(std::runtime_error);

// C++11的noexcept规范
void safeFunction() noexcept;  // 不抛出异常
void mayThrowFunction() noexcept(false);  // 可能抛出异常

// 条件noexcept
template<typename T>
void templateFunction(T value) noexcept(std::is_nothrow_copy_constructible_v<T>);
```

## 标准异常类

### 标准异常层次
```cpp
std::exception
├── std::logic_error
│   ├── std::invalid_argument
│   ├── std::domain_error
│   ├── std::length_error
│   └── std::out_of_range
├── std::runtime_error
│   ├── std::range_error
│   ├── std::overflow_error
│   ├── std::underflow_error
│   └── std::system_error
└── std::bad_alloc
```

### 常用异常类型
```cpp
// 逻辑错误
throw std::invalid_argument("Invalid parameter");
throw std::domain_error("Domain error");
throw std::length_error("Length error");
throw std::out_of_range("Index out of range");

// 运行时错误
throw std::range_error("Range error");
throw std::overflow_error("Overflow");
throw std::underflow_error("Underflow");
throw std::system_error(std::make_error_code(std::errc::no_such_file_or_directory));

// 内存错误
throw std::bad_alloc();
```

## RAII与异常安全

### 异常安全保证
```cpp
class Resource {
private:
    int* data;
    size_t size;
    
public:
    // 基本异常安全
    Resource(size_t s) : size(s) {
        data = new int[size];
        // 如果这里抛出异常，析构函数不会被调用
        // 但构造函数中的分配会被清理
    }
    
    // 强异常安全
    Resource(const Resource& other) : size(other.size) {
        int* newData = new int[size];
        try {
            std::copy(other.data, other.data + size, newData);
        } catch (...) {
            delete[] newData;
            throw;  // 重新抛出异常
        }
        data = newData;
    }
    
    ~Resource() {
        delete[] data;
    }
};
```

### 智能指针与异常
```cpp
#include <memory>

void safeFunction() {
    // 使用智能指针确保异常安全
    auto ptr = std::make_unique<int>(42);
    
    // 即使这里抛出异常，智能指针也会自动清理
    riskyOperation();
    
    // 正常使用
    std::cout << *ptr << std::endl;
}
```

## 异常处理最佳实践

### 异常安全设计
```cpp
class SafeContainer {
private:
    std::vector<int> data;
    
public:
    // 强异常安全：要么成功，要么保持原状态
    void insert(int value) {
        std::vector<int> newData = data;  // 复制
        newData.push_back(value);         // 修改副本
        
        // 如果这里抛出异常，原data不受影响
        data = std::move(newData);        // 原子操作
    }
    
    // 无异常保证：使用noexcept
    void clear() noexcept {
        data.clear();
    }
};
```

### 异常传播
```cpp
// 让异常自然传播
void function1() {
    throw std::runtime_error("Error in function1");
}

void function2() {
    function1();  // 异常会传播到调用者
}

// 捕获并重新抛出
void function3() {
    try {
        function1();
    } catch (const std::exception& e) {
        std::cout << "Caught in function3: " << e.what() << std::endl;
        throw;  // 重新抛出原异常
    }
}

// 抛出新异常
void function4() {
    try {
        function1();
    } catch (const std::exception& e) {
        throw std::runtime_error("Wrapped: " + std::string(e.what()));
    }
}
```

## 异常与构造函数

### 构造函数中的异常
```cpp
class SafeClass {
private:
    std::unique_ptr<int> ptr1;
    std::unique_ptr<int> ptr2;
    
public:
    SafeClass(int value1, int value2) 
        : ptr1(std::make_unique<int>(value1)) {
        
        // 如果这里抛出异常，ptr1会被自动清理
        ptr2 = std::make_unique<int>(value2);
    }
    
    // 如果构造函数抛出异常，析构函数不会被调用
    // 但成员对象的析构函数会被调用
};
```

### 异常与析构函数
```cpp
class SafeDestructor {
public:
    ~SafeDestructor() noexcept {
        try {
            // 清理资源
            cleanup();
        } catch (...) {
            // 析构函数中不应该抛出异常
            // 记录错误但不重新抛出
            std::cerr << "Error in destructor" << std::endl;
        }
    }
    
private:
    void cleanup() {
        // 可能抛出异常的清理操作
    }
};
```

## 自定义异常类

### 继承标准异常
```cpp
class DatabaseException : public std::runtime_error {
private:
    int errorCode;
    
public:
    DatabaseException(const std::string& message, int code)
        : std::runtime_error(message), errorCode(code) {}
    
    int getErrorCode() const {
        return errorCode;
    }
    
    const char* what() const noexcept override {
        static std::string fullMessage = 
            std::runtime_error::what() + " (Code: " + std::to_string(errorCode) + ")";
        return fullMessage.c_str();
    }
};
```

### 异常链
```cpp
class ChainedException : public std::exception {
private:
    std::string message;
    std::exception_ptr cause;
    
public:
    ChainedException(const std::string& msg, std::exception_ptr c = nullptr)
        : message(msg), cause(c) {}
    
    const char* what() const noexcept override {
        return message.c_str();
    }
    
    std::exception_ptr getCause() const {
        return cause;
    }
    
    void rethrowCause() const {
        if (cause) {
            std::rethrow_exception(cause);
        }
    }
};
```

## 异常处理模式

### 异常处理装饰器
```cpp
template<typename Func>
auto withExceptionHandling(Func&& func) {
    return [func = std::forward<Func>(func)](auto&&... args) {
        try {
            return func(std::forward<decltype(args)>(args)...);
        } catch (const std::exception& e) {
            std::cerr << "Exception caught: " << e.what() << std::endl;
            throw;
        }
    };
}

// 使用
auto safeDivide = withExceptionHandling([](int a, int b) {
    if (b == 0) throw std::invalid_argument("Division by zero");
    return a / b;
});
```

### 异常安全包装器
```cpp
template<typename T>
class ExceptionSafeWrapper {
private:
    T value;
    bool valid;
    
public:
    ExceptionSafeWrapper(T&& v) : value(std::move(v)), valid(true) {}
    
    template<typename Func>
    auto apply(Func&& func) -> ExceptionSafeWrapper<decltype(func(value))> {
        if (!valid) {
            throw std::runtime_error("Wrapper is invalid");
        }
        
        try {
            return ExceptionSafeWrapper<decltype(func(value))>(func(value));
        } catch (...) {
            valid = false;
            throw;
        }
    }
    
    T& get() {
        if (!valid) {
            throw std::runtime_error("Wrapper is invalid");
        }
        return value;
    }
    
    bool isValid() const {
        return valid;
    }
};
```
