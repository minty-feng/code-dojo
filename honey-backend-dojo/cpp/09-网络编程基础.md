# 09-网络编程基础

## Socket编程

### 基本Socket操作
```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

class Socket {
private:
    int sockfd;
    
public:
    Socket(int domain, int type, int protocol) {
        sockfd = socket(domain, type, protocol);
        if (sockfd < 0) {
            throw std::runtime_error("Socket creation failed");
        }
    }
    
    ~Socket() {
        if (sockfd >= 0) {
            close(sockfd);
        }
    }
    
    int getFd() const { return sockfd; }
    
    void bind(const sockaddr* addr, socklen_t addrlen) {
        if (::bind(sockfd, addr, addrlen) < 0) {
            throw std::runtime_error("Bind failed");
        }
    }
    
    void listen(int backlog) {
        if (::listen(sockfd, backlog) < 0) {
            throw std::runtime_error("Listen failed");
        }
    }
    
    int accept(sockaddr* addr, socklen_t* addrlen) {
        int clientfd = ::accept(sockfd, addr, addrlen);
        if (clientfd < 0) {
            throw std::runtime_error("Accept failed");
        }
        return clientfd;
    }
    
    void connect(const sockaddr* addr, socklen_t addrlen) {
        if (::connect(sockfd, addr, addrlen) < 0) {
            throw std::runtime_error("Connect failed");
        }
    }
};
```

### TCP服务器
```cpp
#include <iostream>
#include <string>
#include <cstring>

class TCPServer {
private:
    Socket socket;
    int port;
    
public:
    TCPServer(int p) : socket(AF_INET, SOCK_STREAM, 0), port(p) {
        setupServer();
    }
    
    void setupServer() {
        // 设置地址重用
        int opt = 1;
        setsockopt(socket.getFd(), SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
        
        // 绑定地址
        sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
        addr.sin_port = htons(port);
        
        socket.bind(reinterpret_cast<sockaddr*>(&addr), sizeof(addr));
        socket.listen(5);
        
        std::cout << "Server listening on port " << port << std::endl;
    }
    
    void run() {
        while (true) {
            sockaddr_in clientAddr{};
            socklen_t clientLen = sizeof(clientAddr);
            
            int clientfd = socket.accept(
                reinterpret_cast<sockaddr*>(&clientAddr), 
                &clientLen
            );
            
            std::cout << "Client connected: " 
                      << inet_ntoa(clientAddr.sin_addr) << std::endl;
            
            handleClient(clientfd);
            close(clientfd);
        }
    }
    
private:
    void handleClient(int clientfd) {
        char buffer[1024];
        while (true) {
            ssize_t bytesRead = recv(clientfd, buffer, sizeof(buffer) - 1, 0);
            if (bytesRead <= 0) {
                break;
            }
            
            buffer[bytesRead] = '\0';
            std::cout << "Received: " << buffer << std::endl;
            
            // 回显消息
            std::string response = "Echo: " + std::string(buffer);
            send(clientfd, response.c_str(), response.length(), 0);
        }
    }
};
```

### TCP客户端
```cpp
class TCPClient {
private:
    Socket socket;
    std::string host;
    int port;
    
public:
    TCPClient(const std::string& h, int p) 
        : socket(AF_INET, SOCK_STREAM, 0), host(h), port(p) {
        connectToServer();
    }
    
    void connectToServer() {
        sockaddr_in serverAddr{};
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_port = htons(port);
        
        if (inet_pton(AF_INET, host.c_str(), &serverAddr.sin_addr) <= 0) {
            throw std::runtime_error("Invalid address");
        }
        
        socket.connect(
            reinterpret_cast<sockaddr*>(&serverAddr), 
            sizeof(serverAddr)
        );
        
        std::cout << "Connected to " << host << ":" << port << std::endl;
    }
    
    void sendMessage(const std::string& message) {
        send(socket.getFd(), message.c_str(), message.length(), 0);
    }
    
    std::string receiveMessage() {
        char buffer[1024];
        ssize_t bytesRead = recv(socket.getFd(), buffer, sizeof(buffer) - 1, 0);
        if (bytesRead > 0) {
            buffer[bytesRead] = '\0';
            return std::string(buffer);
        }
        return "";
    }
};
```

## UDP编程

### UDP服务器
```cpp
class UDPServer {
private:
    Socket socket;
    int port;
    
public:
    UDPServer(int p) : socket(AF_INET, SOCK_DGRAM, 0), port(p) {
        setupServer();
    }
    
    void setupServer() {
        sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
        addr.sin_port = htons(port);
        
        socket.bind(reinterpret_cast<sockaddr*>(&addr), sizeof(addr));
        std::cout << "UDP Server listening on port " << port << std::endl;
    }
    
    void run() {
        char buffer[1024];
        sockaddr_in clientAddr{};
        socklen_t clientLen = sizeof(clientAddr);
        
        while (true) {
            ssize_t bytesRead = recvfrom(
                socket.getFd(), buffer, sizeof(buffer) - 1, 0,
                reinterpret_cast<sockaddr*>(&clientAddr), &clientLen
            );
            
            if (bytesRead > 0) {
                buffer[bytesRead] = '\0';
                std::cout << "Received from " 
                          << inet_ntoa(clientAddr.sin_addr) 
                          << ": " << buffer << std::endl;
                
                // 回显消息
                std::string response = "Echo: " + std::string(buffer);
                sendto(
                    socket.getFd(), response.c_str(), response.length(), 0,
                    reinterpret_cast<sockaddr*>(&clientAddr), clientLen
                );
            }
        }
    }
};
```

### UDP客户端
```cpp
class UDPClient {
private:
    Socket socket;
    std::string host;
    int port;
    sockaddr_in serverAddr;
    
public:
    UDPClient(const std::string& h, int p) 
        : socket(AF_INET, SOCK_DGRAM, 0), host(h), port(p) {
        setupServerAddr();
    }
    
    void setupServerAddr() {
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_port = htons(port);
        
        if (inet_pton(AF_INET, host.c_str(), &serverAddr.sin_addr) <= 0) {
            throw std::runtime_error("Invalid address");
        }
    }
    
    void sendMessage(const std::string& message) {
        sendto(
            socket.getFd(), message.c_str(), message.length(), 0,
            reinterpret_cast<sockaddr*>(&serverAddr), sizeof(serverAddr)
        );
    }
    
    std::string receiveMessage() {
        char buffer[1024];
        sockaddr_in fromAddr{};
        socklen_t fromLen = sizeof(fromAddr);
        
        ssize_t bytesRead = recvfrom(
            socket.getFd(), buffer, sizeof(buffer) - 1, 0,
            reinterpret_cast<sockaddr*>(&fromAddr), &fromLen
        );
        
        if (bytesRead > 0) {
            buffer[bytesRead] = '\0';
            return std::string(buffer);
        }
        return "";
    }
};
```

## 非阻塞IO

### 非阻塞Socket
```cpp
#include <fcntl.h>
#include <sys/select.h>

class NonBlockingSocket {
private:
    int sockfd;
    
public:
    NonBlockingSocket(int domain, int type, int protocol) {
        sockfd = socket(domain, type, protocol);
        if (sockfd < 0) {
            throw std::runtime_error("Socket creation failed");
        }
        
        // 设置为非阻塞
        int flags = fcntl(sockfd, F_GETFL, 0);
        fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
    }
    
    ~NonBlockingSocket() {
        if (sockfd >= 0) {
            close(sockfd);
        }
    }
    
    int getFd() const { return sockfd; }
    
    bool connect(const sockaddr* addr, socklen_t addrlen) {
        int result = ::connect(sockfd, addr, addrlen);
        if (result == 0) {
            return true;  // 立即连接成功
        }
        
        if (errno == EINPROGRESS) {
            return false;  // 连接进行中
        }
        
        throw std::runtime_error("Connect failed");
    }
    
    bool isConnected() {
        int error = 0;
        socklen_t len = sizeof(error);
        int result = getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &error, &len);
        
        if (result == 0 && error == 0) {
            return true;
        }
        return false;
    }
};
```

### select模型
```cpp
#include <sys/select.h>

class SelectServer {
private:
    int serverFd;
    fd_set readfds;
    int maxFd;
    std::vector<int> clientFds;
    
public:
    SelectServer(int port) {
        setupServer(port);
        FD_ZERO(&readfds);
        FD_SET(serverFd, &readfds);
        maxFd = serverFd;
    }
    
    void run() {
        while (true) {
            fd_set tempfds = readfds;
            
            int activity = select(maxFd + 1, &tempfds, nullptr, nullptr, nullptr);
            
            if (activity < 0) {
                throw std::runtime_error("Select failed");
            }
            
            // 检查新连接
            if (FD_ISSET(serverFd, &tempfds)) {
                acceptNewConnection();
            }
            
            // 检查客户端数据
            for (auto it = clientFds.begin(); it != clientFds.end();) {
                if (FD_ISSET(*it, &tempfds)) {
                    if (handleClientData(*it)) {
                        ++it;
                    } else {
                        close(*it);
                        FD_CLR(*it, &readfds);
                        it = clientFds.erase(it);
                    }
                } else {
                    ++it;
                }
            }
        }
    }
    
private:
    void setupServer(int port) {
        serverFd = socket(AF_INET, SOCK_STREAM, 0);
        
        sockaddr_in addr{};
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = INADDR_ANY;
        addr.sin_port = htons(port);
        
        bind(serverFd, reinterpret_cast<sockaddr*>(&addr), sizeof(addr));
        listen(serverFd, 5);
    }
    
    void acceptNewConnection() {
        sockaddr_in clientAddr{};
        socklen_t clientLen = sizeof(clientAddr);
        
        int clientFd = accept(serverFd, 
                             reinterpret_cast<sockaddr*>(&clientAddr), 
                             &clientLen);
        
        if (clientFd >= 0) {
            clientFds.push_back(clientFd);
            FD_SET(clientFd, &readfds);
            maxFd = std::max(maxFd, clientFd);
            
            std::cout << "New client connected" << std::endl;
        }
    }
    
    bool handleClientData(int clientFd) {
        char buffer[1024];
        ssize_t bytesRead = recv(clientFd, buffer, sizeof(buffer) - 1, 0);
        
        if (bytesRead > 0) {
            buffer[bytesRead] = '\0';
            std::cout << "Received: " << buffer << std::endl;
            
            std::string response = "Echo: " + std::string(buffer);
            send(clientFd, response.c_str(), response.length(), 0);
            return true;
        }
        
        return false;  // 客户端断开连接
    }
};
```

## HTTP客户端

### 简单HTTP客户端
```cpp
#include <sstream>
#include <regex>

class HTTPClient {
private:
    std::string host;
    int port;
    
public:
    HTTPClient(const std::string& h, int p = 80) : host(h), port(p) {}
    
    std::string get(const std::string& path) {
        TCPClient client(host, port);
        
        // 构建HTTP请求
        std::stringstream request;
        request << "GET " << path << " HTTP/1.1\r\n";
        request << "Host: " << host << "\r\n";
        request << "Connection: close\r\n";
        request << "\r\n";
        
        client.sendMessage(request.str());
        
        // 接收响应
        std::string response = client.receiveMessage();
        return parseResponse(response);
    }
    
    std::string post(const std::string& path, const std::string& data) {
        TCPClient client(host, port);
        
        // 构建HTTP请求
        std::stringstream request;
        request << "POST " << path << " HTTP/1.1\r\n";
        request << "Host: " << host << "\r\n";
        request << "Content-Type: application/json\r\n";
        request << "Content-Length: " << data.length() << "\r\n";
        request << "Connection: close\r\n";
        request << "\r\n";
        request << data;
        
        client.sendMessage(request.str());
        
        // 接收响应
        std::string response = client.receiveMessage();
        return parseResponse(response);
    }
    
private:
    std::string parseResponse(const std::string& response) {
        // 简单的响应解析
        std::regex headerRegex(R"(HTTP/\d\.\d (\d+) (.+))");
        std::smatch match;
        
        if (std::regex_search(response, match, headerRegex)) {
            int statusCode = std::stoi(match[1]);
            std::string statusText = match[2];
            
            std::cout << "Status: " << statusCode << " " << statusText << std::endl;
        }
        
        // 查找响应体
        size_t bodyStart = response.find("\r\n\r\n");
        if (bodyStart != std::string::npos) {
            return response.substr(bodyStart + 4);
        }
        
        return response;
    }
};
```

## 网络工具类

### 地址转换
```cpp
#include <arpa/inet.h>

class NetworkUtils {
public:
    static std::string ipToString(uint32_t ip) {
        struct in_addr addr;
        addr.s_addr = ip;
        return std::string(inet_ntoa(addr));
    }
    
    static uint32_t stringToIp(const std::string& ipStr) {
        return inet_addr(ipStr.c_str());
    }
    
    static uint16_t hostToNetwork(uint16_t host) {
        return htons(host);
    }
    
    static uint16_t networkToHost(uint16_t network) {
        return ntohs(network);
    }
    
    static uint32_t hostToNetwork(uint32_t host) {
        return htonl(host);
    }
    
    static uint32_t networkToHost(uint32_t network) {
        return ntohl(network);
    }
};
```

### 超时处理
```cpp
#include <sys/time.h>

class TimeoutSocket {
private:
    int sockfd;
    
public:
    TimeoutSocket(int domain, int type, int protocol) {
        sockfd = socket(domain, type, protocol);
    }
    
    void setReceiveTimeout(int seconds) {
        struct timeval timeout;
        timeout.tv_sec = seconds;
        timeout.tv_usec = 0;
        
        setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, 
                  &timeout, sizeof(timeout));
    }
    
    void setSendTimeout(int seconds) {
        struct timeval timeout;
        timeout.tv_sec = seconds;
        timeout.tv_usec = 0;
        
        setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, 
                  &timeout, sizeof(timeout));
    }
    
    ssize_t recvWithTimeout(void* buffer, size_t length, int flags) {
        return recv(sockfd, buffer, length, flags);
    }
    
    ssize_t sendWithTimeout(const void* buffer, size_t length, int flags) {
        return send(sockfd, buffer, length, flags);
    }
};
```
