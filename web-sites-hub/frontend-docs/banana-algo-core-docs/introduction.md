# Algorithms Core

算法是程序设计的核心，本模块提供Python和C++双语言实现，从基础到高级逐步深入。

## 🎯 学习目标

### 核心能力
- **排序算法**：冒泡、选择、插入、归并、快排、堆排序
- **搜索算法**：二分查找、DFS、BFS
- **双指针技巧**：快慢指针、左右指针、滑动窗口
- **递归与回溯**：回溯算法、剪枝优化
- **分治算法**：归并排序、快速排序、分治思想
- **贪心算法**：贪心策略、最优子结构
- **动态规划**：基础DP、背包问题、进阶DP

### 技术深度
- **时间复杂度**：理解和分析算法效率
- **空间复杂度**：内存使用优化
- **算法设计**：问题建模和算法选择
- **优化技巧**：时间空间权衡

## 📚 学习路径

### 第一阶段：基础算法（2020.01 - 2020.03）
1. **排序算法**：基础排序、高级排序
2. **搜索算法**：线性搜索、二分查找
3. **双指针技巧**：快慢指针、滑动窗口

### 第二阶段：递归与分治（2020.04 - 2020.06）
4. **递归与回溯**：回溯算法、剪枝
5. **分治算法**：分治思想、应用

### 第三阶段：贪心与动态规划（2020.07 - 2020.12）
6. **贪心算法**：贪心策略、应用
7. **动态规划基础**：DP思想、状态转移
8. **背包问题**：01背包、完全背包、多重背包
9. **DP进阶**：区间DP、树形DP、状态压缩

## 🔧 环境要求

### Python
- Python 3.8+
- 标准库

### C++
- C++11或更高
- GCC 7+ / Clang 5+ / MSVC 2017+

## 🚀 快速开始

### Python
```bash
# 运行示例
python sorting.py
python binary_search.py

# 运行测试
python -m pytest tests/
```

### C++
```bash
# 编译
g++ -std=c++11 sorting.cpp -o sorting
g++ -std=c++11 binary_search.cpp -o binary_search

# 运行
./sorting
./binary_search
```

## 📊 复杂度对比

| 算法类型 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---------|-----------|-----------|---------|
| 冒泡排序 | O(n²) | O(1) | 小规模数据 |
| 快速排序 | O(n log n) | O(log n) | 通用排序 |
| 归并排序 | O(n log n) | O(n) | 稳定排序 |
| 二分查找 | O(log n) | O(1) | 有序数组 |
| DFS | O(V+E) | O(V) | 图遍历 |
| BFS | O(V+E) | O(V) | 最短路径 |
| 动态规划 | O(n²) | O(n) | 最优化问题 |

## 💡 学习建议

### 学习方法
1. **理论结合实践**：先理解原理，再看代码实现
2. **对比学习**：Python和C++实现对比
3. **画图辅助**：画出算法的执行过程
4. **刷题巩固**：在LeetCode上练习相关题目

### 推荐顺序
1. 先学Python实现（语法简洁，易于理解）
2. 再学C++实现（理解性能优化）
3. 对比两种语言的实现差异
4. 分析时间和空间复杂度
5. 练习相关算法题目

## 🎯 应用场景

### 排序算法
- 数据排序
- Top K问题
- 去重

### 搜索算法
- 有序数组查找
- 图遍历
- 最短路径

### 双指针
- 数组去重
- 两数之和
- 滑动窗口

### 递归回溯
- 全排列
- 组合问题
- 数独求解

### 分治算法
- 归并排序
- 快速排序
- 大数乘法

### 贪心算法
- 活动选择
- 最小生成树
- 最短路径

### 动态规划
- 最长公共子序列
- 背包问题
- 股票买卖

## 📚 参考资料

- 《算法导论》
- 《算法竞赛入门经典》
- [LeetCode](https://leetcode.com/)
- [VisuAlgo](https://visualgo.net/)

## 🌟 总结

算法是编程的核心，掌握常用算法能大幅提升编程能力。通过Python和C++双语言学习，既能理解算法思想，又能掌握实现细节。

建议循序渐进，从简单的排序和搜索开始，逐步过渡到复杂的动态规划，最后掌握高级算法技巧。每学习一个算法，都要：
1. 理解其原理和思想
2. 掌握基本实现
3. 分析时间和空间复杂度
4. 了解实际应用场景
5. 练习相关算法题目

