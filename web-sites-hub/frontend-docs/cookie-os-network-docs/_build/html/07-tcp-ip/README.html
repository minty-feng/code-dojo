

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TCP/IP协议详解 &mdash; OS &amp; Network Core 1.0.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=f07cb45e" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=34088549"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=beaddf03"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="HTTP协议与实战" href="../08-http/index.html" />
    <link rel="prev" title="TCP-IP协议详解" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../index.html" class="icon icon-home">
            OS & Network Core
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">OS &amp; Network Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01-process-thread/index.html">进程与线程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02-process-scheduling/index.html">进程调度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03-memory-management/index.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04-file-system/index.html">文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05-concurrency-sync/index.html">并发与同步</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06-deadlock/index.html">死锁处理</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">TCP-IP协议详解</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">TCP-IP协议详解</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">💡 核心结论</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">1. TCP/IP模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">1.1 四层模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">1.2 数据封装</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tcp">2. TCP协议</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">2.1 TCP头部格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">2.2 三次握手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">2.3 四次挥手</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">2.4 可靠传输</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">2.5 流量控制（滑动窗口）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">2.6 拥塞控制</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#udp">3. UDP协议</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">3.1 UDP头部格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">3.2 UDP特点</a></li>
<li class="toctree-l4"><a class="reference internal" href="#udp-vs-tcp">3.3 UDP vs TCP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">3.4 UDP应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">3.5 UDP编程示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ip">4. IP协议</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">4.1 IP地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">4.2 IP数据包格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">4.3 IP路由</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nat">4.4 NAT（网络地址转换）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id18">5. 常见问题</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#q1-time-wait2msl">Q1: 为什么TIME_WAIT要等2MSL？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#q2-time-wait">Q2: 如何减少TIME_WAIT？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#q3-tcpnagle">Q3: TCP为什么需要Nagle算法？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#q4-udp">Q4: 为什么UDP不可靠但还要用？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">6. 性能优化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">6.1 TCP优化</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">6.2 应用层优化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id22">参考资源</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../08-http/index.html">HTTP协议与实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09-socket/index.html">Socket编程实战</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10-network-tools/index.html">网络工具大全</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11-network-security/index.html">网络安全基础</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">OS & Network Core</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">TCP-IP协议详解</a></li>
      <li class="breadcrumb-item active">TCP/IP协议详解</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/07-tcp-ip/README.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="tcp-ip">
<h1>TCP/IP协议详解<a class="headerlink" href="#tcp-ip" title="Link to this heading"></a></h1>
<section id="id1">
<h2>💡 核心结论<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p><strong>TCP三次握手建立连接，四次挥手断开连接</strong></p></li>
<li><p><strong>TCP通过序列号、确认号、重传实现可靠传输</strong></p></li>
<li><p><strong>滑动窗口控制流量，慢启动和拥塞避免控制拥塞</strong></p></li>
<li><p><strong>TIME_WAIT状态防止旧连接数据包干扰新连接</strong></p></li>
<li><p><strong>UDP无连接、不可靠，但延迟低，适合实时应用</strong></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="id2">
<h2>1. TCP/IP模型<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<section id="id3">
<h3>1.1 四层模型<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>应用层    HTTP, FTP, DNS, SMTP
    ↓
传输层    TCP, UDP
    ↓
网络层    IP, ICMP, ARP
    ↓
链路层    Ethernet, WiFi
</pre></div>
</div>
</section>
<section id="id4">
<h3>1.2 数据封装<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>应用数据
    ↓
[TCP头部 | 应用数据]          TCP段（Segment）
    ↓
[IP头部 | TCP头部 | 应用数据]   IP数据包（Packet）
    ↓
[以太网头部 | IP数据包 | 尾部]   以太网帧（Frame）
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="tcp">
<h2>2. TCP协议<a class="headerlink" href="#tcp" title="Link to this heading"></a></h2>
<section id="id5">
<h3>2.1 TCP头部格式<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">tcp_header</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">source_port</span><span class="p">;</span><span class="w">      </span><span class="c1">// 源端口</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">dest_port</span><span class="p">;</span><span class="w">        </span><span class="c1">// 目标端口</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">seq_num</span><span class="p">;</span><span class="w">          </span><span class="c1">// 序列号</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ack_num</span><span class="p">;</span><span class="w">          </span><span class="c1">// 确认号</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">data_offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">  </span><span class="c1">// 头部长度</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">reserved</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">     </span><span class="c1">// 保留</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">flags</span><span class="p">;</span><span class="w">            </span><span class="c1">// 标志位</span>
<span class="w">    </span><span class="c1">// URG, ACK, PSH, RST, SYN, FIN</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">window</span><span class="p">;</span><span class="w">           </span><span class="c1">// 窗口大小</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">checksum</span><span class="p">;</span><span class="w">         </span><span class="c1">// 校验和</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">urgent_ptr</span><span class="p">;</span><span class="w">       </span><span class="c1">// 紧急指针</span>
<span class="w">    </span><span class="c1">// 可选项...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>关键字段</strong>：</p>
<ul class="simple">
<li><p><strong>seq_num</strong>：本次发送数据的第一个字节的序列号</p></li>
<li><p><strong>ack_num</strong>：期望接收的下一个字节的序列号</p></li>
<li><p><strong>flags</strong>：控制标志（SYN, ACK, FIN, RST等）</p></li>
<li><p><strong>window</strong>：接收窗口大小</p></li>
</ul>
</section>
<section id="id6">
<h3>2.2 三次握手<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>客户端                                  服务器
  │                                       │
  │── SYN seq=x ───────────────────────→ │  LISTEN
  │                                       │  SYN_RCVD
  │←─ SYN+ACK seq=y, ack=x+1 ────────── │
  │                                       │
  │── ACK seq=x+1, ack=y+1 ────────────→ │  ESTABLISHED
  │                                       │
ESTABLISHED                           ESTABLISHED
</pre></div>
</div>
<p><strong>为什么是三次？</strong></p>
<ol class="arabic simple">
<li><p><strong>第一次</strong>：客户端告诉服务器”我要连接你”</p></li>
<li><p><strong>第二次</strong>：服务器回复”我收到了，我也要连接你”</p></li>
<li><p><strong>第三次</strong>：客户端确认”好的，连接建立”</p></li>
</ol>
<p><strong>防止历史连接</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>如果只有两次握手：
1. 客户端发送SYN（但网络延迟）
2. 客户端超时重发SYN
3. 服务器收到第二个SYN，回复SYN+ACK
4. 连接建立，正常通信
5. 第一个延迟的SYN到达服务器
6. 服务器又建立一个连接（错误！）

三次握手可以让客户端拒绝旧的SYN+ACK
</pre></div>
</div>
<p><strong>代码示例</strong>：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 客户端</span>
<span class="kt">int</span><span class="w"> </span><span class="n">sockfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">server_addr</span><span class="p">;</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">;</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htons</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>

<span class="c1">// 发起三次握手</span>
<span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="id7">
<h3>2.3 四次挥手<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>客户端                                  服务器
  │                                       │
  │── FIN seq=u ───────────────────────→ │  CLOSE_WAIT
FIN_WAIT_1                                │
  │                                       │
  │←─ ACK ack=u+1 ──────────────────── │
FIN_WAIT_2                                │
  │                                       │
  │←─ FIN seq=v ───────────────────── │  LAST_ACK
TIME_WAIT                                 │
  │                                       │
  │── ACK ack=v+1 ────────────────────→ │  CLOSED
  │                                       │
  │ (等待2MSL)                           │
CLOSED                                    │
</pre></div>
</div>
<p><strong>为什么是四次？</strong></p>
<ul class="simple">
<li><p>TCP是全双工，双方都需要关闭</p></li>
<li><p><strong>第一次</strong>：客户端说”我发完了”（FIN）</p></li>
<li><p><strong>第二次</strong>：服务器说”我知道了”（ACK）</p></li>
<li><p><strong>第三次</strong>：服务器说”我也发完了”（FIN）</p></li>
<li><p><strong>第四次</strong>：客户端说”我知道了”（ACK）</p></li>
</ul>
<p><strong>TIME_WAIT状态</strong>：</p>
<ul class="simple">
<li><p>持续时间：2MSL（Maximum Segment Lifetime，通常60秒）</p></li>
<li><p>目的：</p>
<ol class="arabic simple">
<li><p>确保最后的ACK到达对方</p></li>
<li><p>让旧连接的数据包在网络中消失</p></li>
</ol>
</li>
</ul>
<p><strong>代码示例</strong>：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 关闭连接</span>
<span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span><span class="w">  </span><span class="c1">// 触发四次挥手</span>

<span class="c1">// 避免TIME_WAIT的socket复用</span>
<span class="kt">int</span><span class="w"> </span><span class="n">reuse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_REUSEADDR</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">reuse</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">reuse</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="id8">
<h3>2.4 可靠传输<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p><strong>序列号和确认号</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>发送方: seq=100, 发送100字节
接收方: ack=200 (期望接收第200字节)

发送方: seq=200, 发送50字节
接收方: ack=250

序列号标识数据位置，确认号确认收到
</pre></div>
</div>
<p><strong>超时重传</strong>：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 简化的重传机制</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">retransmit</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">seq</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timeval</span><span class="w"> </span><span class="n">send_time</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">retries</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">check_timeout</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timeval</span><span class="w"> </span><span class="n">now</span><span class="p">;</span>
<span class="w">    </span><span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">packet</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">sent_queue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">packet</span><span class="p">.</span><span class="n">send_time</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">RTO</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 超时，重传</span>
<span class="w">            </span><span class="n">send_packet</span><span class="p">(</span><span class="n">packet</span><span class="p">);</span>
<span class="w">            </span><span class="n">packet</span><span class="p">.</span><span class="n">retries</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">packet</span><span class="p">.</span><span class="n">send_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>快速重传</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>接收方收到乱序包时，立即发送重复ACK

发送方收到3个重复ACK，立即重传
（不等超时）

seq=100 ───→ ✓ ack=200
seq=200 ───→ ✗ 丢失
seq=300 ───→ ✓ ack=200 (重复1)
seq=400 ───→ ✓ ack=200 (重复2)
seq=500 ───→ ✓ ack=200 (重复3)
seq=200 ───→ ✓ 快速重传！
</pre></div>
</div>
</section>
<section id="id9">
<h3>2.5 流量控制（滑动窗口）<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p><strong>原理</strong>：接收方告诉发送方自己的缓冲区大小</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>接收方:
recv_window = BUFFER_SIZE - (next_seq - acked_seq)
在TCP头部的window字段通知发送方

发送方:
send_window = min(recv_window, cwnd)  // cwnd是拥塞窗口
只能发送send_window大小的数据

示例:
接收方缓冲区: 4KB
已接收未处理: 2KB
→ 通告窗口: 2KB

发送方最多再发2KB数据
</pre></div>
</div>
<p><strong>零窗口探测</strong>：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 接收方窗口为0</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">recv_window</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 发送方定期发送1字节探测包</span>
<span class="w">    </span><span class="n">send_probe</span><span class="p">();</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">probe_interval</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id10">
<h3>2.6 拥塞控制<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p><strong>四个算法</strong>：</p>
<p><strong>1. 慢启动（Slow Start）</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>初始cwnd = 1 MSS
每收到一个ACK，cwnd += 1
指数增长: 1 → 2 → 4 → 8 → 16 ...

到达ssthresh（慢启动阈值）后，进入拥塞避免
</pre></div>
</div>
<p><strong>2. 拥塞避免（Congestion Avoidance）</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>线性增长: cwnd += 1/cwnd (每RTT增加1)
16 → 17 → 18 → 19 ...

如果发生超时:
  ssthresh = cwnd / 2
  cwnd = 1
  重新慢启动
</pre></div>
</div>
<p><strong>3. 快速重传（Fast Retransmit）</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">收到3个重复ACK</span><span class="p">:</span>
  <span class="n">立即重传丢失的包</span>
  <span class="n">进入快速恢复</span>
</pre></div>
</div>
<p><strong>4. 快速恢复（Fast Recovery）</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">收到3个重复ACK后</span><span class="p">:</span>
  <span class="n">ssthresh</span> <span class="o">=</span> <span class="n">cwnd</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="n">cwnd</span> <span class="o">=</span> <span class="n">ssthresh</span> <span class="o">+</span> <span class="mi">3</span>
  <span class="n">线性增长</span>

<span class="n">收到新ACK</span><span class="p">:</span>
  <span class="n">cwnd</span> <span class="o">=</span> <span class="n">ssthresh</span>
  <span class="n">进入拥塞避免</span>
</pre></div>
</div>
<p><strong>拥塞控制图示</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cwnd
 │     慢启动    │  拥塞避免  │快速恢复│拥塞避免
 │    /          │  /         │/       │ /
 │   /           │ /          │        │/
 │  /            │/           │        │
 │ /             ↓ 3个重复ACK │        │
 │/              │            ↓        │
 └───────────────────────────────────→ 时间
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="udp">
<h2>3. UDP协议<a class="headerlink" href="#udp" title="Link to this heading"></a></h2>
<section id="id11">
<h3>3.1 UDP头部格式<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">udp_header</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">source_port</span><span class="p">;</span><span class="w">   </span><span class="c1">// 源端口 (2字节)</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">dest_port</span><span class="p">;</span><span class="w">     </span><span class="c1">// 目标端口 (2字节)</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w">        </span><span class="c1">// UDP长度 (2字节)</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">checksum</span><span class="p">;</span><span class="w">      </span><span class="c1">// 校验和 (2字节)</span>
<span class="w">    </span><span class="c1">// 数据部分...</span>
<span class="p">};</span>
<span class="c1">// 总共只有8字节！</span>
</pre></div>
</div>
</section>
<section id="id12">
<h3>3.2 UDP特点<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p><strong>优点</strong>：</p>
<ul class="simple">
<li><p>✅ 无连接，无握手开销</p></li>
<li><p>✅ 低延迟（无重传等待）</p></li>
<li><p>✅ 头部简单（只有8字节）</p></li>
<li><p>✅ 支持广播和多播</p></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul class="simple">
<li><p>❌ 不可靠（可能丢包、乱序、重复）</p></li>
<li><p>❌ 无流量控制</p></li>
<li><p>❌ 无拥塞控制</p></li>
</ul>
</section>
<section id="udp-vs-tcp">
<h3>3.3 UDP vs TCP<a class="headerlink" href="#udp-vs-tcp" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>特性</p></th>
<th class="head"><p>TCP</p></th>
<th class="head"><p>UDP</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>连接</p></td>
<td><p>面向连接</p></td>
<td><p>无连接</p></td>
</tr>
<tr class="row-odd"><td><p>可靠性</p></td>
<td><p>可靠</p></td>
<td><p>不可靠</p></td>
</tr>
<tr class="row-even"><td><p>顺序</p></td>
<td><p>有序</p></td>
<td><p>可能乱序</p></td>
</tr>
<tr class="row-odd"><td><p>速度</p></td>
<td><p>慢（头部20-60字节）</p></td>
<td><p>快（头部8字节）</p></td>
</tr>
<tr class="row-even"><td><p>应用</p></td>
<td><p>HTTP, FTP, SSH</p></td>
<td><p>DNS, 视频, 游戏</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id13">
<h3>3.4 UDP应用场景<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>✅ DNS查询：单个数据包，丢包重查即可
✅ 视频直播：实时性优先，丢几帧无所谓
✅ 在线游戏：低延迟优先，丢包插值
✅ VoIP：实时语音，延迟&gt;可靠性
✅ DHCP：简单请求-响应

❌ 文件传输：需要可靠性
❌ 网页浏览：需要完整数据
❌ 邮件：需要可靠性
</pre></div>
</div>
</section>
<section id="id14">
<h3>3.5 UDP编程示例<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// UDP服务器</span>
<span class="kt">int</span><span class="w"> </span><span class="n">sockfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">server_addr</span><span class="p">;</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">;</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htons</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INADDR_ANY</span><span class="p">;</span>

<span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>

<span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">client_addr</span><span class="p">;</span>
<span class="kt">socklen_t</span><span class="w"> </span><span class="n">addr_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">client_addr</span><span class="p">);</span>

<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                    </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Received: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">           </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span><span class="w"> </span><span class="n">addr_len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// UDP客户端</span>
<span class="kt">int</span><span class="w"> </span><span class="n">sockfd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="n">SOCK_DGRAM</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr_in</span><span class="w"> </span><span class="n">server_addr</span><span class="p">;</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_family</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AF_INET</span><span class="p">;</span>
<span class="n">server_addr</span><span class="p">.</span><span class="n">sin_port</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htons</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello UDP&quot;</span><span class="p">;</span>
<span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">message</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">       </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>

<span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Response: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="ip">
<h2>4. IP协议<a class="headerlink" href="#ip" title="Link to this heading"></a></h2>
<section id="id15">
<h3>4.1 IP地址<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<p><strong>IPv4</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>32位，4个字节
点分十进制：192.168.1.1

网络部分 + 主机部分
A类：0.0.0.0 - 127.255.255.255
B类：128.0.0.0 - 191.255.255.255
C类：192.0.0.0 - 223.255.255.255

子网掩码：255.255.255.0 (/24)
网络地址：192.168.1.0
广播地址：192.168.1.255
可用主机：192.168.1.1 - 192.168.1.254
</pre></div>
</div>
<p><strong>IPv6</strong>：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>128位，16个字节
冒号十六进制：2001:0db8:85a3:0000:0000:8a2e:0370:7334

简化：
2001:db8:85a3::8a2e:370:7334
（连续的0可省略）
</pre></div>
</div>
</section>
<section id="id16">
<h3>4.2 IP数据包格式<a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ip_header</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">version</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">       </span><span class="c1">// 版本号 (4)</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">ihl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">           </span><span class="c1">// 头部长度</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">tos</span><span class="p">;</span><span class="w">               </span><span class="c1">// 服务类型</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">total_length</span><span class="p">;</span><span class="w">      </span><span class="c1">// 总长度</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">identification</span><span class="p">;</span><span class="w">    </span><span class="c1">// 标识</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">flags</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">         </span><span class="c1">// 标志</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">fragment_offset</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span><span class="w"> </span><span class="c1">// 片偏移</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">ttl</span><span class="p">;</span><span class="w">               </span><span class="c1">// 生存时间</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w">  </span><span class="n">protocol</span><span class="p">;</span><span class="w">          </span><span class="c1">// 协议 (TCP=6, UDP=17)</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">checksum</span><span class="p">;</span><span class="w">          </span><span class="c1">// 校验和</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source_ip</span><span class="p">;</span><span class="w">         </span><span class="c1">// 源IP</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dest_ip</span><span class="p">;</span><span class="w">           </span><span class="c1">// 目标IP</span>
<span class="w">    </span><span class="c1">// 可选项...</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="id17">
<h3>4.3 IP路由<a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<p><strong>路由表</strong>：</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 查看路由表</span>
$<span class="w"> </span>route<span class="w"> </span>-n
Destination<span class="w">     </span>Gateway<span class="w">         </span>Genmask<span class="w">         </span>Flags<span class="w"> </span>Iface
<span class="m">0</span>.0.0.0<span class="w">         </span><span class="m">192</span>.168.1.1<span class="w">     </span><span class="m">0</span>.0.0.0<span class="w">         </span>UG<span class="w">    </span>eth0
<span class="m">192</span>.168.1.0<span class="w">     </span><span class="m">0</span>.0.0.0<span class="w">         </span><span class="m">255</span>.255.255.0<span class="w">   </span>U<span class="w">     </span>eth0

<span class="c1"># 路由选择：最长前缀匹配</span>
目标:<span class="w"> </span><span class="m">192</span>.168.1.100
匹配:<span class="w"> </span><span class="m">192</span>.168.1.0/24（更具体）→<span class="w"> </span>直接投递
不匹配:<span class="w"> </span><span class="m">0</span>.0.0.0/0<span class="w"> </span>→<span class="w"> </span>默认网关
</pre></div>
</div>
</section>
<section id="nat">
<h3>4.4 NAT（网络地址转换）<a class="headerlink" href="#nat" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>内网 → 外网
源IP: 192.168.1.100:5000
NAT转换: 203.0.113.5:60000
目标IP: 8.8.8.8:53

外网 → 内网
源IP: 8.8.8.8:53
目标IP: 203.0.113.5:60000
NAT转换: 192.168.1.100:5000

NAT表:
内部地址:端口         外部地址:端口
192.168.1.100:5000 ↔ 203.0.113.5:60000
192.168.1.101:6000 ↔ 203.0.113.5:60001
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="id18">
<h2>5. 常见问题<a class="headerlink" href="#id18" title="Link to this heading"></a></h2>
<section id="q1-time-wait2msl">
<h3>Q1: 为什么TIME_WAIT要等2MSL？<a class="headerlink" href="#q1-time-wait2msl" title="Link to this heading"></a></h3>
<p><strong>A</strong>:</p>
<ol class="arabic simple">
<li><p>确保最后的ACK到达（如果丢失，对方会重发FIN，需要能接收并回复）</p></li>
<li><p>让旧连接的数据包在网络中消失</p></li>
</ol>
</section>
<section id="q2-time-wait">
<h3>Q2: 如何减少TIME_WAIT？<a class="headerlink" href="#q2-time-wait" title="Link to this heading"></a></h3>
<p><strong>A</strong>:</p>
<ul class="simple">
<li><p>调整<code class="docutils literal notranslate"><span class="pre">tcp_tw_reuse</span></code>和<code class="docutils literal notranslate"><span class="pre">tcp_tw_recycle</span></code>（需谨慎）</p></li>
<li><p>使用SO_REUSEADDR</p></li>
<li><p>客户端使用短连接，由客户端主动关闭</p></li>
</ul>
</section>
<section id="q3-tcpnagle">
<h3>Q3: TCP为什么需要Nagle算法？<a class="headerlink" href="#q3-tcpnagle" title="Link to this heading"></a></h3>
<p><strong>A</strong>:</p>
<ul class="simple">
<li><p>合并小包，减少网络拥塞</p></li>
<li><p>但增加延迟，交互式应用需禁用（TCP_NODELAY）</p></li>
</ul>
</section>
<section id="q4-udp">
<h3>Q4: 为什么UDP不可靠但还要用？<a class="headerlink" href="#q4-udp" title="Link to this heading"></a></h3>
<p><strong>A</strong>:</p>
<ul class="simple">
<li><p>低延迟优先级高于可靠性（实时应用）</p></li>
<li><p>可以在应用层实现可靠性（如QUIC）</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="id19">
<h2>6. 性能优化<a class="headerlink" href="#id19" title="Link to this heading"></a></h2>
<section id="id20">
<h3>6.1 TCP优化<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 增大缓冲区</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.core.rmem_max<span class="o">=</span><span class="m">16777216</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.core.wmem_max<span class="o">=</span><span class="m">16777216</span>

<span class="c1"># TCP窗口缩放</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_window_scaling<span class="o">=</span><span class="m">1</span>

<span class="c1"># 快速回收TIME_WAIT</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_tw_reuse<span class="o">=</span><span class="m">1</span>

<span class="c1"># SYN队列大小</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.ipv4.tcp_max_syn_backlog<span class="o">=</span><span class="m">8192</span>

<span class="c1"># 连接队列大小</span>
sysctl<span class="w"> </span>-w<span class="w"> </span>net.core.somaxconn<span class="o">=</span><span class="m">1024</span>
</pre></div>
</div>
</section>
<section id="id21">
<h3>6.2 应用层优化<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// TCP_NODELAY: 禁用Nagle算法</span>
<span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">IPPROTO_TCP</span><span class="p">,</span><span class="w"> </span><span class="n">TCP_NODELAY</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">flag</span><span class="p">));</span>

<span class="c1">// SO_KEEPALIVE: 保活机制</span>
<span class="kt">int</span><span class="w"> </span><span class="n">keepalive</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_KEEPALIVE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keepalive</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">keepalive</span><span class="p">));</span>

<span class="c1">// SO_RCVBUF: 接收缓冲区</span>
<span class="kt">int</span><span class="w"> </span><span class="n">bufsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8192</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="w"> </span><span class="n">SOL_SOCKET</span><span class="p">,</span><span class="w"> </span><span class="n">SO_RCVBUF</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufsize</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">bufsize</span><span class="p">));</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="id22">
<h2>参考资源<a class="headerlink" href="#id22" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p>《TCP/IP详解 卷1：协议》</p></li>
<li><p>RFC 793 (TCP)</p></li>
<li><p>RFC 768 (UDP)</p></li>
<li><p>Linux源码：<code class="docutils literal notranslate"><span class="pre">net/ipv4/tcp.c</span></code></p></li>
<li><p>Wireshark实战教程</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="index.html" class="btn btn-neutral float-left" title="TCP-IP协议详解" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="../08-http/index.html" class="btn btn-neutral float-right" title="HTTP协议与实战" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2025, Code Dojo。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>