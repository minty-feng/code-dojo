

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>06-内存管理 &mdash; Backend Tutorial 1.0.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=f07cb45e" />

  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=34088549"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/translations.js?v=beaddf03"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="07-异常处理" href="07-exceptions.html" />
    <link rel="prev" title="05-STL标准模板库" href="05-stl.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../index.html" class="icon icon-home">
            Backend Tutorial
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Backend Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">C++ 教程</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="README.html">C++ 后端开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="01-environment-setup.html">01-编译运行环境搭建</a></li>
<li class="toctree-l2"><a class="reference internal" href="02-basic-syntax.html">02-CPP基础语法</a></li>
<li class="toctree-l2"><a class="reference internal" href="03-bitwise.html">03-位运算详解</a></li>
<li class="toctree-l2"><a class="reference internal" href="04-oop.html">04-面向对象编程基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="05-stl.html">05-STL标准模板库</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">06-内存管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">内存模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">内存布局</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">栈内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">堆内存</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id6">动态内存分配</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#newdelete">new和delete</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">内存泄漏</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">异常安全</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id9">智能指针</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unique-ptr">unique_ptr详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shared-ptr">shared_ptr详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="#weak-ptr">weak_ptr详解</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#raii">RAII（资源获取即初始化）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">基本概念</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">锁管理</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">内存池</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id13">简单内存池实现</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id14">内存对齐</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">对齐规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">对齐控制</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id17">内存调试</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#valgrind">Valgrind使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#addresssanitizer">AddressSanitizer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">自定义内存检查</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">常见内存错误与检测</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">内存错误类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">检测工具使用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">预防最佳实践</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="07-exceptions.html">07-异常处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="08-concurrency.html">08-并发编程基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="09-networking.html">09-网络编程基础</a></li>
<li class="toctree-l2"><a class="reference internal" href="10-performance.html">10-性能优化技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="11-templates.html">11-模板编程</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../python/index.html">Python 教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../java/index.html">Java 教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nodejs/index.html">Node.js 教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../go/index.html">Golang 教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rust/index.html">Rust 教程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../shell/index.html">Shell 教程</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Backend Tutorial</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">C++ 教程</a></li>
      <li class="breadcrumb-item active">06-内存管理</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/cpp/06-memory.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>06-内存管理<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<section id="id2">
<h2>内存模型<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>内存管理是C++编程中的核心概念，理解内存模型对于编写高效、安全的程序至关重要。C++提供了直接的内存控制能力，这既是其优势也是其挑战。掌握内存管理技术可以避免内存泄漏、提高程序性能，并编写出更加健壮的代码。</p>
<section id="id3">
<h3>内存布局<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>程序运行时，内存被划分为不同的区域，每个区域有不同的用途和特性。理解这些区域的特点有助于更好地管理内存。</p>
<p><strong>代码段（Text Segment）：</strong></p>
<ul class="simple">
<li><p>存储程序的机器码指令</p></li>
<li><p>只读区域，程序运行时不能修改</p></li>
<li><p>通常位于内存的低地址区域</p></li>
<li><p>包含程序的执行逻辑</p></li>
</ul>
<p><strong>数据段（Data Segment）：</strong></p>
<ul class="simple">
<li><p>存储已初始化的全局变量和静态变量</p></li>
<li><p>程序启动时分配，程序结束时释放</p></li>
<li><p>分为只读数据段和可读写数据段</p></li>
<li><p>包含程序的全局状态信息</p></li>
</ul>
<p><strong>BSS段（Block Started by Symbol）：</strong></p>
<ul class="simple">
<li><p>存储未初始化的全局变量和静态变量</p></li>
<li><p>程序启动时自动初始化为0</p></li>
<li><p>不占用可执行文件的空间</p></li>
<li><p>提高程序加载效率</p></li>
</ul>
<p><strong>堆（Heap）：</strong></p>
<ul class="simple">
<li><p>动态分配的内存区域</p></li>
<li><p>通过new/delete或malloc/free管理</p></li>
<li><p>内存分配和释放的时间不确定</p></li>
<li><p>需要程序员手动管理</p></li>
</ul>
<p><strong>栈（Stack）：</strong></p>
<ul class="simple">
<li><p>存储局部变量和函数调用信息</p></li>
<li><p>自动管理，后进先出（LIFO）</p></li>
<li><p>内存分配和释放速度快</p></li>
<li><p>大小有限，通常几MB</p></li>
</ul>
</section>
<section id="id4">
<h3>栈内存<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>栈内存是自动管理的内存区域，具有高效、安全的特点。它是函数调用和局部变量存储的主要场所。</p>
<p><strong>栈内存的特点：</strong></p>
<ul class="simple">
<li><p>自动分配和释放，无需程序员干预</p></li>
<li><p>分配速度快，只需要移动栈指针</p></li>
<li><p>内存连续，缓存友好</p></li>
<li><p>大小有限，通常几MB</p></li>
<li><p>后进先出，符合函数调用模式</p></li>
</ul>
<p><strong>栈内存的使用：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">localVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">              </span><span class="c1">// 栈上分配</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w">                 </span><span class="c1">// 栈上数组</span>
<span class="w">    </span><span class="c1">// 函数结束时自动释放</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>栈内存的优势：</strong></p>
<ul class="simple">
<li><p>无需手动管理，避免内存泄漏</p></li>
<li><p>分配速度快，性能优秀</p></li>
<li><p>自动清理，异常安全</p></li>
<li><p>内存局部性好，缓存命中率高</p></li>
</ul>
<p><strong>栈内存的限制：</strong></p>
<ul class="simple">
<li><p>大小有限，不适合大对象</p></li>
<li><p>生命周期固定，灵活性差</p></li>
<li><p>递归深度受限</p></li>
<li><p>不能动态调整大小</p></li>
</ul>
</section>
<section id="id5">
<h3>堆内存<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>堆内存是动态分配的内存区域，提供了更大的灵活性，但也带来了更多的管理复杂性。</p>
<p><strong>堆内存的特点：</strong></p>
<ul class="simple">
<li><p>手动管理，程序员控制分配和释放</p></li>
<li><p>大小灵活，可以分配任意大小的内存</p></li>
<li><p>生命周期灵活，可以跨函数使用</p></li>
<li><p>分配速度相对较慢</p></li>
<li><p>可能产生内存碎片</p></li>
</ul>
<p><strong>堆内存的使用：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">         </span><span class="c1">// 堆上分配</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w">      </span><span class="c1">// 堆上数组</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w">                     </span><span class="c1">// 释放单个对象</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">array</span><span class="p">;</span><span class="w">                 </span><span class="c1">// 释放数组</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>堆内存的优势：</strong></p>
<ul class="simple">
<li><p>大小灵活，适合大对象</p></li>
<li><p>生命周期灵活，可以跨函数使用</p></li>
<li><p>可以动态调整大小</p></li>
<li><p>适合不确定大小的数据结构</p></li>
</ul>
<p><strong>堆内存的挑战：</strong></p>
<ul class="simple">
<li><p>需要手动管理，容易出错</p></li>
<li><p>可能产生内存泄漏</p></li>
<li><p>分配速度较慢</p></li>
<li><p>可能产生内存碎片</p></li>
</ul>
</section>
</section>
<section id="id6">
<h2>动态内存分配<a class="headerlink" href="#id6" title="Link to this heading"></a></h2>
<p>动态内存分配是C++中重要的内存管理技术，正确使用可以大大提高程序的灵活性。通过动态分配，可以在运行时决定需要多少内存，这对于处理不确定大小的数据特别有用。</p>
<section id="newdelete">
<h3>new和delete<a class="headerlink" href="#newdelete" title="Link to this heading"></a></h3>
<p>new和delete是C++的动态内存分配操作符，提供了类型安全的内存管理。它们比C语言的malloc和free更加安全，因为它们会自动调用构造函数和析构函数。</p>
<p><strong>new和delete的优势：</strong></p>
<ul class="simple">
<li><p>类型安全，编译器检查类型匹配</p></li>
<li><p>自动调用构造函数和析构函数</p></li>
<li><p>支持异常处理</p></li>
<li><p>与C++对象模型集成良好</p></li>
</ul>
<p><strong>单个对象分配：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w">    </span><span class="c1">// 分配并初始化</span>
<span class="k">delete</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span><span class="w">                </span><span class="c1">// 释放内存</span>
</pre></div>
</div>
<p><strong>数组分配：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="w">    </span><span class="c1">// 分配数组</span>
<span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span><span class="w">              </span><span class="c1">// 释放数组</span>
</pre></div>
</div>
<p><strong>对象分配：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span><span class="o">*</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyClass</span><span class="p">();</span><span class="w">  </span><span class="c1">// 调用构造函数</span>
<span class="k">delete</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w">                    </span><span class="c1">// 调用析构函数</span>
</pre></div>
</div>
<p><strong>对象数组分配：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">MyClass</span><span class="o">*</span><span class="w"> </span><span class="n">objs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyClass</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span><span class="w">  </span><span class="c1">// 调用构造函数</span>
<span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">objs</span><span class="p">;</span><span class="w">                   </span><span class="c1">// 调用析构函数</span>
</pre></div>
</div>
<p><strong>注意事项：</strong></p>
<ul class="simple">
<li><p>new和delete必须配对使用</p></li>
<li><p>new[]和delete[]必须配对使用</p></li>
<li><p>不要混用new/delete和malloc/free</p></li>
<li><p>释放后要将指针设为nullptr</p></li>
</ul>
</section>
<section id="id7">
<h3>内存泄漏<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>内存泄漏是动态内存管理中的常见问题，需要特别注意。内存泄漏会导致程序占用越来越多的内存，最终可能导致系统崩溃。</p>
<p><strong>内存泄漏的原因：</strong></p>
<ul class="simple">
<li><p>忘记调用delete释放内存</p></li>
<li><p>异常导致delete未执行</p></li>
<li><p>指针丢失，无法释放内存</p></li>
<li><p>循环引用导致无法释放</p></li>
</ul>
<p><strong>错误示例：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">badFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 忘记delete ptr;</span>
<span class="w">    </span><span class="c1">// 内存泄漏！</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>防止内存泄漏的方法：</strong></p>
<ul class="simple">
<li><p>使用RAII（资源获取即初始化）</p></li>
<li><p>使用智能指针</p></li>
<li><p>异常安全编程</p></li>
<li><p>代码审查和测试</p></li>
</ul>
<p><strong>正确示例：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Resource</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Resource</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">data</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="o">~</span><span class="n">Resource</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">delete</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="id8">
<h3>异常安全<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>异常安全是动态内存管理中的重要概念，确保程序在异常情况下也能正确管理内存。</p>
<p><strong>异常安全问题：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">riskyFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">84</span><span class="p">);</span><span class="w">        </span><span class="c1">// 如果这里抛出异常，ptr1泄漏</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">ptr2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>异常安全解决方案：</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">safeFunction</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr1</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="w">    </span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr2</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">84</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// 即使抛出异常，智能指针也会自动释放</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>异常安全保证级别：</strong></p>
<ul class="simple">
<li><p>基本保证：不泄漏资源，对象处于有效状态</p></li>
<li><p>强保证：操作要么成功，要么保持原状态</p></li>
<li><p>无异常保证：操作不会抛出异常</p></li>
</ul>
</section>
</section>
<section id="id9">
<h2>智能指针<a class="headerlink" href="#id9" title="Link to this heading"></a></h2>
<p>智能指针自动管理内存，避免手动 <code class="docutils literal notranslate"><span class="pre">new/delete</span></code> 的风险。C++11 提供三种智能指针应对不同场景。</p>
<section id="unique-ptr">
<h3>unique_ptr详解<a class="headerlink" href="#unique-ptr" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code> 独占所有权，不可拷贝只能移动。适用于明确单一所有者的场景，零开销。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="c1">// 创建</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr1</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="k">auto</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// 移动语义</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span><span class="w">  </span><span class="c1">// ptr1变为nullptr</span>

<span class="c1">// 自定义删除器</span>
<span class="k">auto</span><span class="w"> </span><span class="n">deleter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Deleting: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">deleter</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr4</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="n">deleter</span><span class="p">);</span>

<span class="c1">// 数组版本</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="shared-ptr">
<h3>shared_ptr详解<a class="headerlink" href="#shared-ptr" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 创建</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr1</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="k">auto</span><span class="w"> </span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>

<span class="c1">// 共享所有权</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Reference count: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// 2</span>

<span class="c1">// 自定义删除器</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr4</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">),</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Custom delete&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 弱引用</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">weak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weak</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">locked</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="weak-ptr">
<h3>weak_ptr详解<a class="headerlink" href="#weak-ptr" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">weak</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared</span><span class="p">;</span>

<span class="c1">// 检查是否有效</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">weak</span><span class="p">.</span><span class="n">expired</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weak</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Value: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">locked</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 获取引用计数</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Use count: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">weak</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="raii">
<h2>RAII（资源获取即初始化）<a class="headerlink" href="#raii" title="Link to this heading"></a></h2>
<p>RAII 是 C++ 资源管理的核心模式：构造函数获取资源，析构函数释放资源。利用栈对象自动析构特性。</p>
<section id="id10">
<h3>基本概念<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>RAII 将资源生命周期绑定到对象生命周期，自动管理文件、锁、内存等资源。</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FileHandle</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">file</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">FileHandle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">file</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Cannot open file&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="o">~</span><span class="n">FileHandle</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 禁用拷贝</span>
<span class="w">    </span><span class="n">FileHandle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FileHandle</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">FileHandle</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FileHandle</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 允许移动</span>
<span class="w">    </span><span class="n">FileHandle</span><span class="p">(</span><span class="n">FileHandle</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">file</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">other</span><span class="p">.</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">FileHandle</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">FileHandle</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="w"> </span><span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="w">            </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">file</span><span class="p">;</span>
<span class="w">            </span><span class="n">other</span><span class="p">.</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="id11">
<h3>锁管理<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LockGuard</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">mutex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">LockGuard</span><span class="p">(</span><span class="n">mutex</span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">mtx</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mtx</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="o">~</span><span class="n">LockGuard</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">mtx</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 禁用拷贝和移动</span>
<span class="w">    </span><span class="n">LockGuard</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LockGuard</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">LockGuard</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LockGuard</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">LockGuard</span><span class="p">(</span><span class="n">LockGuard</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">LockGuard</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">LockGuard</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="id12">
<h2>内存池<a class="headerlink" href="#id12" title="Link to this heading"></a></h2>
<section id="id13">
<h3>简单内存池实现<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SimpleMemoryPool</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">memory</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">used</span><span class="p">;</span>
<span class="w">    </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">SimpleMemoryPool</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">poolSize</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">size</span><span class="p">(</span><span class="n">poolSize</span><span class="p">),</span><span class="w"> </span><span class="n">used</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="o">~</span><span class="n">SimpleMemoryPool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">memory</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">used</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 内存不足</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span>
<span class="w">        </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">used</span><span class="p">;</span>
<span class="w">        </span><span class="n">used</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bytes</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 简单实现：不实际释放，只是重置</span>
<span class="w">        </span><span class="n">used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="id14">
<h2>内存对齐<a class="headerlink" href="#id14" title="Link to this heading"></a></h2>
<section id="id15">
<h3>对齐规则<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">AlignedStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">      </span><span class="c1">// 1字节</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">       </span><span class="c1">// 4字节，对齐到4字节边界</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w">    </span><span class="c1">// 8字节，对齐到8字节边界</span>
<span class="p">};</span>
<span class="c1">// 总大小：24字节（1 + 3填充 + 4 + 8）</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">PackedStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span><span class="w">  </span><span class="c1">// GCC属性，取消对齐</span>
<span class="c1">// 总大小：13字节</span>
</pre></div>
</div>
</section>
<section id="id16">
<h3>对齐控制<a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstddef&gt;</span>

<span class="c1">// 查询对齐要求</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">        </span><span class="c1">// 4</span>
<span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">alignof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w">     </span><span class="c1">// 8</span>

<span class="c1">// 对齐分配</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aligned_alloc</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w">   </span><span class="c1">// 16字节对齐，64字节大小</span>
<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="id17">
<h2>内存调试<a class="headerlink" href="#id17" title="Link to this heading"></a></h2>
<section id="valgrind">
<h3>Valgrind使用<a class="headerlink" href="#valgrind" title="Link to this heading"></a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 内存泄漏检查</span>
valgrind<span class="w"> </span>--leak-check<span class="o">=</span>full<span class="w"> </span>./program

<span class="c1"># 内存错误检查</span>
valgrind<span class="w"> </span>--tool<span class="o">=</span>memcheck<span class="w"> </span>./program

<span class="c1"># 性能分析</span>
valgrind<span class="w"> </span>--tool<span class="o">=</span>callgrind<span class="w"> </span>./program
</pre></div>
</div>
</section>
<section id="addresssanitizer">
<h3>AddressSanitizer<a class="headerlink" href="#addresssanitizer" title="Link to this heading"></a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 编译时启用</span>
g++<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-g<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>source.cpp

<span class="c1"># 运行时检查内存错误</span>
./program
</pre></div>
</div>
</section>
<section id="id18">
<h3>自定义内存检查<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MemoryTracker</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">allocated</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">deallocated</span><span class="p">;</span>
<span class="w">    </span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">allocated</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Allocated: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; bytes&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">deallocated</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Deallocated: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; bytes&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">report</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Total allocated: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">allocated</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; bytes&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Total deallocated: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">deallocated</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; bytes&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Leaked: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">allocated</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">deallocated</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; bytes&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="id19">
<h2>常见内存错误与检测<a class="headerlink" href="#id19" title="Link to this heading"></a></h2>
<section id="id20">
<h3>内存错误类型<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1. 内存泄漏 - 分配后忘记释放</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">leak</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span><span class="w">  </span><span class="c1">// 忘记delete，内存泄漏！</span>
<span class="p">}</span>

<span class="c1">// 2. 重复释放 - Double Free</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">doubleFree</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// 未定义行为！</span>
<span class="p">}</span>

<span class="c1">// 3. 悬空指针 - Use After Free</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">useAfterFree</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">  </span><span class="c1">// 未定义行为！</span>
<span class="p">}</span>

<span class="c1">// 4. 数组越界</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bufferOverflow</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">    </span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// 越界！</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 5. 错误的delete方式</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">wrongDelete</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// 错误！应该用delete</span>

<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">arr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 错误！应该用delete[]</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id21">
<h3>检测工具使用<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<p><strong>Valgrind（Linux必备）：</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 编译时加调试信息</span>
g++<span class="w"> </span>-g<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>source.cpp

<span class="c1"># 内存泄漏检测</span>
valgrind<span class="w"> </span>--leak-check<span class="o">=</span>full<span class="w"> </span>--show-leak-kinds<span class="o">=</span>all<span class="w"> </span>./program

<span class="c1"># 输出示例</span>
<span class="c1"># ==12345== LEAK SUMMARY:</span>
<span class="c1"># ==12345==    definitely lost: 40 bytes in 1 blocks</span>
<span class="c1"># ==12345==    indirectly lost: 0 bytes in 0 blocks</span>

<span class="c1"># 未初始化内存使用</span>
valgrind<span class="w"> </span>--track-origins<span class="o">=</span>yes<span class="w"> </span>./program
</pre></div>
</div>
<p><strong>AddressSanitizer（推荐，速度快）：</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 编译时启用（GCC/Clang）</span>
g++<span class="w"> </span>-fsanitize<span class="o">=</span>address<span class="w"> </span>-g<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>source.cpp

<span class="c1"># 运行程序自动检测</span>
./program

<span class="c1"># 检测类型：</span>
<span class="c1"># - 堆缓冲区溢出</span>
<span class="c1"># - 栈缓冲区溢出</span>
<span class="c1"># - Use after free</span>
<span class="c1"># - Use after return</span>
<span class="c1"># - Double free</span>
</pre></div>
</div>
<p><strong>LeakSanitizer（内存泄漏专用）：</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 编译时启用</span>
g++<span class="w"> </span>-fsanitize<span class="o">=</span>leak<span class="w"> </span>-g<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>source.cpp

<span class="c1"># 运行结束时报告泄漏</span>
./program
</pre></div>
</div>
<p><strong>静态分析（编译期检查）：</strong></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Clang静态分析器</span>
clang++<span class="w"> </span>--analyze<span class="w"> </span>source.cpp

<span class="c1"># Cppcheck</span>
cppcheck<span class="w"> </span>--enable<span class="o">=</span>all<span class="w"> </span>source.cpp

<span class="c1"># Clang-Tidy</span>
clang-tidy<span class="w"> </span>source.cpp<span class="w"> </span>--<span class="w"> </span>-std<span class="o">=</span>c++17
</pre></div>
</div>
</section>
<section id="id22">
<h3>预防最佳实践<a class="headerlink" href="#id22" title="Link to this heading"></a></h3>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ✅ 1. 使用智能指针</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span><span class="w">  </span><span class="c1">// 自动释放</span>

<span class="c1">// ✅ 2. RAII封装资源</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FileHandle</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">fp</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">FileHandle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">fp</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="o">~</span><span class="n">FileHandle</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="w"> </span><span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ✅ 3. 使用容器代替数组</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="w">  </span><span class="c1">// 自动管理内存</span>

<span class="c1">// ✅ 4. 删除后置空指针</span>
<span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 防止悬空指针</span>

<span class="c1">// ✅ 5. 禁用拷贝或正确实现深拷贝</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NoCopy</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">NoCopy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">NoCopy</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>核心思想：让编译器和库管理内存，而不是手动管理。</strong></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="05-stl.html" class="btn btn-neutral float-left" title="05-STL标准模板库" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="07-exceptions.html" class="btn btn-neutral float-right" title="07-异常处理" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2025, Code Dojo。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>