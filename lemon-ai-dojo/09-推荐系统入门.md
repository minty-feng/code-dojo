# 推荐系统入门

## 💡 核心结论

1. **推荐系统解决信息过载问题，提高用户体验**
2. **协同过滤是最经典的推荐算法**
3. **内容推荐基于物品特征，协同过滤基于用户行为**
4. **深度学习推荐模型可以自动学习特征交互**
5. **推荐系统需要平衡准确性、多样性、新颖性**

---

## 1. 推荐系统类型

### 1.1 协同过滤

**基于用户（User-Based）**：
```
找到相似用户，推荐他们喜欢的物品

用户A喜欢：电影1, 电影2, 电影3
用户B喜欢：电影1, 电影2, 电影4
→ 推荐电影4给用户A
```

**基于物品（Item-Based）**：
```
找到相似物品，推荐给喜欢类似物品的用户

用户喜欢电影1
电影1与电影2相似
→ 推荐电影2
```

### 1.2 内容推荐

```python
# 基于物品特征
item_features = {
    'movie1': ['动作', '科幻', '美国'],
    'movie2': ['动作', '冒险', '美国'],
    'movie3': ['爱情', '剧情', '法国']
}

user_profile = ['动作', '科幻']

# 计算相似度
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

texts = [' '.join(features) for features in item_features.values()]
user_text = ' '.join(user_profile)

vectorizer = TfidfVectorizer()
item_vectors = vectorizer.fit_transform(texts)
user_vector = vectorizer.transform([user_text])

similarities = cosine_similarity(user_vector, item_vectors)
```

---

## 2. 协同过滤实现

### 2.1 用户相似度

```python
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

# 用户-物品评分矩阵
ratings = np.array([
    [5, 3, 0, 1],  # 用户1
    [4, 0, 0, 1],  # 用户2
    [1, 1, 0, 5],  # 用户3
    [0, 0, 5, 4],  # 用户4
])

# 计算用户相似度
user_similarity = cosine_similarity(ratings)
print(user_similarity)

# 预测评分
def predict_rating(user_id, item_id, ratings, similarity):
    # 找到对该物品有评分的用户
    rated_users = np.where(ratings[:, item_id] > 0)[0]
    
    if len(rated_users) == 0:
        return np.mean(ratings[user_id][ratings[user_id] > 0])
    
    # 加权平均
    sim_scores = similarity[user_id, rated_users]
    item_ratings = ratings[rated_users, item_id]
    
    weighted_sum = np.dot(sim_scores, item_ratings)
    sim_sum = np.sum(np.abs(sim_scores))
    
    if sim_sum == 0:
        return 0
    
    return weighted_sum / sim_sum
```

### 2.2 矩阵分解

```python
# SVD分解
from scipy.sparse.linalg import svds

# 用户-物品矩阵
R = ratings.copy()

# 均值中心化
user_ratings_mean = np.mean(R, axis=1, keepdims=True)
R_centered = R - user_ratings_mean

# SVD分解
U, sigma, Vt = svds(R_centered, k=2)

# 预测矩阵
sigma_diag = np.diag(sigma)
predicted_ratings = np.dot(np.dot(U, sigma_diag), Vt) + user_ratings_mean

print(predicted_ratings)
```

---

## 3. 评估指标

```python
# 准确率指标
from sklearn.metrics import mean_squared_error, mean_absolute_error

# RMSE
rmse = np.sqrt(mean_squared_error(y_true, y_pred))

# MAE
mae = mean_absolute_error(y_true, y_pred)

# 排序指标
def precision_at_k(recommended, relevant, k=10):
    recommended_at_k = recommended[:k]
    num_hit = len(set(recommended_at_k) & set(relevant))
    return num_hit / k

def recall_at_k(recommended, relevant, k=10):
    recommended_at_k = recommended[:k]
    num_hit = len(set(recommended_at_k) & set(relevant))
    return num_hit / len(relevant)

# NDCG
def ndcg_at_k(recommended, relevant, k=10):
    dcg = sum([1 / np.log2(i + 2) for i, item in enumerate(recommended[:k]) 
               if item in relevant])
    idcg = sum([1 / np.log2(i + 2) for i in range(min(len(relevant), k))])
    return dcg / idcg if idcg > 0 else 0
```

---

## 参考资源

- 《推荐系统实践》- 项亮
- Surprise库文档

