# 深度推荐模型

## 💡 核心结论

1. **DeepFM结合FM和深度网络，自动学习特征交互**
2. **Wide & Deep同时学习记忆和泛化**
3. **DIN动态计算用户兴趣，适合电商推荐**
4. **双塔模型支持向量检索，适合大规模推荐**
5. **序列推荐模型（如GRU4Rec）捕获用户行为序列**

---

## 1. DeepFM

```python
import torch
import torch.nn as nn

class DeepFM(nn.Module):
    def __init__(self, feature_sizes, embed_dim=8):
        super(DeepFM, self).__init__()
        
        # FM部分：嵌入层
        self.embeddings = nn.ModuleList([
            nn.Embedding(size, embed_dim) for size in feature_sizes
        ])
        
        # Deep部分：DNN
        self.dnn = nn.Sequential(
            nn.Linear(len(feature_sizes) * embed_dim, 128),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(64, 1)
        )
        
        # FM一阶权重
        self.linear = nn.ModuleList([
            nn.Embedding(size, 1) for size in feature_sizes
        ])
    
    def forward(self, x):
        # FM一阶部分
        linear_part = sum([emb(x[:, i]).squeeze(1) 
                          for i, emb in enumerate(self.linear)])
        
        # FM二阶部分
        embeddings = [emb(x[:, i]) for i, emb in enumerate(self.embeddings)]
        embeddings = torch.stack(embeddings, dim=1)
        
        square_of_sum = torch.sum(embeddings, dim=1) ** 2
        sum_of_square = torch.sum(embeddings ** 2, dim=1)
        fm_part = 0.5 * torch.sum(square_of_sum - sum_of_square, dim=1, keepdim=True)
        
        # Deep部分
        deep_input = embeddings.view(x.size(0), -1)
        deep_part = self.dnn(deep_input)
        
        # 组合
        output = linear_part + fm_part + deep_part
        return torch.sigmoid(output)
```

---

## 2. Wide & Deep

```python
class WideAndDeep(nn.Module):
    def __init__(self, wide_dim, deep_dim):
        super(WideAndDeep, self).__init__()
        
        # Wide部分：线性模型
        self.wide = nn.Linear(wide_dim, 1)
        
        # Deep部分：DNN
        self.deep = nn.Sequential(
            nn.Linear(deep_dim, 128),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 1)
        )
    
    def forward(self, wide_input, deep_input):
        wide_out = self.wide(wide_input)
        deep_out = self.deep(deep_input)
        output = wide_out + deep_out
        return torch.sigmoid(output)
```

---

## 3. 序列推荐

```python
class GRU4Rec(nn.Module):
    def __init__(self, num_items, embedding_dim, hidden_size):
        super(GRU4Rec, self).__init__()
        self.embedding = nn.Embedding(num_items, embedding_dim)
        self.gru = nn.GRU(embedding_dim, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, num_items)
    
    def forward(self, item_seq):
        # item_seq: [batch_size, seq_len]
        embedded = self.embedding(item_seq)
        output, hidden = self.gru(embedded)
        logits = self.fc(output[:, -1, :])
        return logits
```

---

## 参考资源

- 《深度学习推荐系统》- 王喆
- RecBole推荐系统库

