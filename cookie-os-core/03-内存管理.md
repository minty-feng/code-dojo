# å†…å­˜ç®¡ç†

## ğŸ’¡ æ ¸å¿ƒç»“è®º

1. **è™šæ‹Ÿå†…å­˜æ˜¯ç°ä»£æ“ä½œç³»ç»Ÿçš„åŸºçŸ³ï¼Œæä¾›è¿›ç¨‹éš”ç¦»å’Œå†…å­˜æŠ½è±¡**
2. **åˆ†é¡µæ¯”åˆ†æ®µæ›´çµæ´»ï¼Œæ®µé¡µå¼ç»“åˆä¸¤è€…ä¼˜ç‚¹**
3. **å¤šçº§é¡µè¡¨å‡å°‘å†…å­˜å ç”¨ï¼ŒTLBåŠ é€Ÿåœ°å€è½¬æ¢**
4. **LRUæ˜¯æœ€ä¼˜é¡µé¢ç½®æ¢ç®—æ³•çš„è¿‘ä¼¼ï¼ŒClockç®—æ³•æ˜¯LRUçš„é«˜æ•ˆå®ç°**
5. **å†™æ—¶å¤åˆ¶(COW)æ˜¯forkå’Œå†…å­˜ä¼˜åŒ–çš„å…³é”®æŠ€æœ¯**

---

## 1. å†…å­˜å±‚æ¬¡ç»“æ„

```
å¯„å­˜å™¨  <1ns   KBçº§    æœ€å¿«
L1ç¼“å­˜  ~1ns   32-64KB
L2ç¼“å­˜  ~4ns   256KB-1MB
L3ç¼“å­˜  ~10ns  8-32MB
å†…å­˜    ~100ns GBçº§
SSD     ~10Î¼s  TBçº§
HDD     ~10ms  TBçº§    æœ€æ…¢
```

**å±€éƒ¨æ€§åŸç†**ï¼š
- **æ—¶é—´å±€éƒ¨æ€§**ï¼šæœ€è¿‘è®¿é—®çš„æ•°æ®å¾ˆå¯èƒ½å†æ¬¡è®¿é—®
- **ç©ºé—´å±€éƒ¨æ€§**ï¼šç›¸é‚»åœ°å€çš„æ•°æ®å¾ˆå¯èƒ½è¢«è®¿é—®

---

## 2. åœ°å€ç©ºé—´

### 2.1 ç‰©ç†åœ°å€ vs è™šæ‹Ÿåœ°å€

```
ç‰©ç†åœ°å€ï¼šå®é™…å†…å­˜åœ°å€
è™šæ‹Ÿåœ°å€ï¼šç¨‹åºä½¿ç”¨çš„åœ°å€

è¿›ç¨‹A: 0x1000 â”€â”
              â”œâ”€> ç‰©ç†åœ°å€: 0x5000
è¿›ç¨‹B: 0x1000 â”€â”˜  (æ˜ å°„åˆ°ä¸åŒç‰©ç†é¡µ)
```

**è™šæ‹Ÿåœ°å€çš„ä¼˜åŠ¿**ï¼š
1. è¿›ç¨‹éš”ç¦»ï¼ˆå®‰å…¨ï¼‰
2. å†…å­˜ç¢ç‰‡æ•´ç†ï¼ˆçµæ´»ï¼‰
3. ç¨‹åºé‡å®šä½ï¼ˆç®€å•ï¼‰
4. å…±äº«å†…å­˜ï¼ˆé«˜æ•ˆï¼‰

### 2.2 å†…å­˜å¸ƒå±€

```c
// å…¸å‹çš„è¿›ç¨‹å†…å­˜å¸ƒå±€ï¼ˆ32ä½ï¼‰

0xFFFFFFFF  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   å†…æ ¸ç©ºé—´   â”‚ 1GB
0xC0000000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚     æ ˆ       â”‚ â†“ å‘ä¸‹å¢é•¿
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚      â†•      â”‚
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚     å †       â”‚ â†‘ å‘ä¸Šå¢é•¿
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚   BSSæ®µ     â”‚ æœªåˆå§‹åŒ–æ•°æ®
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚   æ•°æ®æ®µ     â”‚ å·²åˆå§‹åŒ–æ•°æ®
            â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚   ä»£ç æ®µ     â”‚ åªè¯»
0x08048000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
            â”‚   ä¿ç•™åŒº     â”‚
0x00000000  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æŸ¥çœ‹è¿›ç¨‹å†…å­˜å¸ƒå±€**ï¼š
```c
#include <stdio.h>

int global_init = 10;       // æ•°æ®æ®µ
int global_uninit;          // BSSæ®µ
const int readonly = 5;     // ä»£ç æ®µï¼ˆåªè¯»ï¼‰

int main() {
    int stack_var = 20;     // æ ˆ
    int *heap_var = malloc(sizeof(int));  // å †
    
    printf("ä»£ç æ®µ: %p\n", main);
    printf("æ•°æ®æ®µ: %p\n", &global_init);
    printf("BSSæ®µ:  %p\n", &global_uninit);
    printf("å †:    %p\n", heap_var);
    printf("æ ˆ:    %p\n", &stack_var);
    
    return 0;
}
```

---

## 3. åˆ†é¡µæœºåˆ¶

### 3.1 åŸºæœ¬åˆ†é¡µ

**åŸç†**ï¼šå°†è™šæ‹Ÿåœ°å€ç©ºé—´å’Œç‰©ç†å†…å­˜éƒ½åˆ†æˆå›ºå®šå¤§å°çš„é¡µ

```
é¡µå¤§å°ï¼šé€šå¸¸4KB

è™šæ‹Ÿåœ°å€ = [é¡µå· | é¡µå†…åç§»]
ä¾‹å¦‚ï¼ˆ32ä½ï¼Œ4KBé¡µï¼‰ï¼š
  20ä½é¡µå· + 12ä½åç§»
  æ”¯æŒï¼š2^20 = 1Mä¸ªé¡µ = 4GBåœ°å€ç©ºé—´
```

**åœ°å€è½¬æ¢**ï¼š
```c
struct page_table_entry {
    unsigned int present : 1;    // åœ¨å†…å­˜ä¸­
    unsigned int writable : 1;   // å¯å†™
    unsigned int user : 1;       // ç”¨æˆ·å¯è®¿é—®
    unsigned int accessed : 1;   // å·²è®¿é—®
    unsigned int dirty : 1;      // å·²ä¿®æ”¹
    unsigned int reserved : 7;
    unsigned int pfn : 20;       // ç‰©ç†é¡µæ¡†å· (Page Frame Number)
};

// åœ°å€è½¬æ¢å‡½æ•°
unsigned int translate(unsigned int virtual_addr) {
    unsigned int page_num = virtual_addr >> 12;  // é«˜20ä½
    unsigned int offset = virtual_addr & 0xFFF;  // ä½12ä½
    
    page_table_entry pte = page_table[page_num];
    
    if (!pte.present) {
        page_fault();  // ç¼ºé¡µä¸­æ–­
        return 0;
    }
    
    unsigned int physical_addr = (pte.pfn << 12) | offset;
    return physical_addr;
}
```

### 3.2 å¤šçº§é¡µè¡¨

**é—®é¢˜**ï¼š32ä½ç³»ç»Ÿï¼Œ4KBé¡µï¼Œé¡µè¡¨å¤§å° = 2^20 * 4B = 4MBï¼ˆæ¯ä¸ªè¿›ç¨‹ï¼ï¼‰

**è§£å†³**ï¼šå¤šçº§é¡µè¡¨

```
ä¸¤çº§é¡µè¡¨ï¼ˆ32ä½ï¼‰ï¼š
è™šæ‹Ÿåœ°å€ = [10ä½ä¸€çº§é¡µå· | 10ä½äºŒçº§é¡µå· | 12ä½åç§»]

ä¸€çº§é¡µè¡¨ï¼š1024é¡¹ = 4KB
äºŒçº§é¡µè¡¨ï¼š1024é¡¹ = 4KBï¼ˆæŒ‰éœ€åˆ†é…ï¼‰

èŠ‚çœï¼šåªéœ€ä¸€çº§é¡µè¡¨ + å®é™…ä½¿ç”¨çš„äºŒçº§é¡µè¡¨
```

**åœ°å€è½¬æ¢**ï¼š
```c
// ä¸¤çº§é¡µè¡¨è½¬æ¢
unsigned int translate_2level(unsigned int va) {
    unsigned int pde_index = (va >> 22) & 0x3FF;  // ä¸€çº§ç´¢å¼•
    unsigned int pte_index = (va >> 12) & 0x3FF;  // äºŒçº§ç´¢å¼•
    unsigned int offset = va & 0xFFF;             // åç§»
    
    // 1. æŸ¥ä¸€çº§é¡µè¡¨
    pde_t pde = page_directory[pde_index];
    if (!pde.present) {
        page_fault();
        return 0;
    }
    
    // 2. æŸ¥äºŒçº§é¡µè¡¨
    pte_t *page_table = (pte_t*)pde.pt_base;
    pte_t pte = page_table[pte_index];
    if (!pte.present) {
        page_fault();
        return 0;
    }
    
    // 3. ç»„åˆç‰©ç†åœ°å€
    return (pte.pfn << 12) | offset;
}
```

**Linux x86-64 å››çº§é¡µè¡¨**ï¼š
```
PGD (Page Global Directory)  -> å…¨å±€é¡µç›®å½•
PUD (Page Upper Directory)   -> ä¸Šå±‚é¡µç›®å½•
PMD (Page Middle Directory)  -> ä¸­é—´é¡µç›®å½•
PTE (Page Table Entry)       -> é¡µè¡¨é¡¹

è™šæ‹Ÿåœ°å€ï¼ˆ48ä½ï¼‰ï¼š
[9ä½PGD | 9ä½PUD | 9ä½PMD | 9ä½PTE | 12ä½åç§»]
```

### 3.3 TLBï¼ˆTranslation Lookaside Bufferï¼‰

**é—®é¢˜**ï¼šæ¯æ¬¡å†…å­˜è®¿é—®éœ€è¦å¤šæ¬¡é¡µè¡¨æŸ¥è¯¢

**è§£å†³**ï¼šTLBç¼“å­˜æœ€è¿‘çš„åœ°å€è½¬æ¢

```c
struct tlb_entry {
    unsigned int vpn;  // è™šæ‹Ÿé¡µå·
    unsigned int pfn;  // ç‰©ç†é¡µæ¡†å·
    bool valid;
};

tlb_entry tlb[TLB_SIZE];

unsigned int translate_with_tlb(unsigned int va) {
    unsigned int vpn = va >> 12;
    unsigned int offset = va & 0xFFF;
    
    // 1. æŸ¥TLB
    for (int i = 0; i < TLB_SIZE; i++) {
        if (tlb[i].valid && tlb[i].vpn == vpn) {
            // TLBå‘½ä¸­
            return (tlb[i].pfn << 12) | offset;
        }
    }
    
    // 2. TLBæœªå‘½ä¸­ï¼ŒæŸ¥é¡µè¡¨
    unsigned int pfn = page_table_walk(vpn);
    
    // 3. æ›´æ–°TLB
    tlb_insert(vpn, pfn);
    
    return (pfn << 12) | offset;
}
```

**TLBæ€§èƒ½**ï¼š
- TLBå¤§å°ï¼š64-1024é¡¹
- å‘½ä¸­ç‡ï¼š>95%
- å‘½ä¸­æ—¶é—´ï¼š~1ns
- æœªå‘½ä¸­æ—¶é—´ï¼š~100ns

**TLBåˆ·æ–°**ï¼š
- è¿›ç¨‹åˆ‡æ¢æ—¶éœ€è¦åˆ·æ–°TLBï¼ˆå¼€é”€å¤§ï¼ï¼‰
- è§£å†³ï¼šASIDï¼ˆAddress Space IDï¼‰æ ‡è®°è¿›ç¨‹

---

## 4. åˆ†æ®µæœºåˆ¶

### 4.1 åŸºæœ¬åˆ†æ®µ

**åŸç†**ï¼šæŒ‰é€»è¾‘å•å…ƒï¼ˆä»£ç ã€æ•°æ®ã€æ ˆï¼‰åˆ†æ®µ

```c
struct segment {
    unsigned int base;      // æ®µåŸºå€
    unsigned int limit;     // æ®µé•¿åº¦
    unsigned char type;     // æ®µç±»å‹ï¼ˆä»£ç /æ•°æ®ï¼‰
    unsigned char privilege; // ç‰¹æƒçº§
};

segment segment_table[MAX_SEGMENTS];

// åœ°å€è½¬æ¢
unsigned int translate_segment(unsigned int seg, unsigned int offset) {
    if (offset > segment_table[seg].limit) {
        segmentation_fault();
        return 0;
    }
    return segment_table[seg].base + offset;
}
```

**ä¼˜ç‚¹**ï¼š
- ç¬¦åˆç¨‹åºé€»è¾‘ç»“æ„
- ä¿æŠ¤ç²’åº¦çµæ´»
- å…±äº«æ–¹ä¾¿

**ç¼ºç‚¹**ï¼š
- å¤–éƒ¨ç¢ç‰‡ï¼ˆä¸åŒå¤§å°çš„æ®µï¼‰
- æ®µè¡¨ç®¡ç†å¤æ‚

### 4.2 æ®µé¡µå¼

**ç»“åˆåˆ†æ®µå’Œåˆ†é¡µçš„ä¼˜ç‚¹**ï¼š

```
è™šæ‹Ÿåœ°å€ = [æ®µå· | é¡µå· | é¡µå†…åç§»]

1. å…ˆç”¨æ®µå·æŸ¥æ®µè¡¨ï¼Œå¾—åˆ°é¡µè¡¨åŸºå€
2. ç”¨é¡µå·æŸ¥é¡µè¡¨ï¼Œå¾—åˆ°ç‰©ç†é¡µæ¡†å·
3. ç»„åˆç‰©ç†åœ°å€
```

**Intel x86çš„æ®µé¡µå¼**ï¼š
```
æ®µé€‰æ‹©å­ï¼š13ä½ç´¢å¼• + 1ä½TI + 2ä½RPL
æ®µæè¿°ç¬¦ï¼šåŸºå€ + é™é•¿ + å±æ€§
```

---

## 5. é¡µé¢ç½®æ¢ç®—æ³•

### 5.1 æœ€ä¼˜ç®—æ³•ï¼ˆOPTï¼‰

**åŸç†**ï¼šæ›¿æ¢æœªæ¥æœ€é•¿æ—¶é—´ä¸ç”¨çš„é¡µï¼ˆç†è®ºæœ€ä¼˜ï¼‰

```c
int opt_replace(int pages[], int n, int capacity) {
    // å¯¹æ¯ä¸ªé¡µé¢ï¼Œè®¡ç®—ä¸‹æ¬¡ä½¿ç”¨æ—¶é—´
    int farthest = -1;
    int victim = -1;
    
    for (int i = 0; i < capacity; i++) {
        int next_use = find_next_use(pages, n, frames[i]);
        if (next_use > farthest) {
            farthest = next_use;
            victim = i;
        }
    }
    
    return victim;
}
```

**é—®é¢˜**ï¼šæ— æ³•é¢„çŸ¥æœªæ¥ï¼Œä»…ç”¨äºæ€§èƒ½å¯¹æ¯”

### 5.2 å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰

**åŸç†**ï¼šæ›¿æ¢æœ€æ—©è¿›å…¥çš„é¡µ

```c
int fifo_replace() {
    static int pointer = 0;
    int victim = pointer;
    pointer = (pointer + 1) % capacity;
    return victim;
}
```

**Beladyå¼‚å¸¸**ï¼šå¢åŠ é¡µæ¡†æ•°åè€Œå¢åŠ ç¼ºé¡µç‡ï¼

```
é¡µé¢å¼•ç”¨åºåˆ—ï¼š1 2 3 4 1 2 5 1 2 3 4 5

3ä¸ªé¡µæ¡†ï¼šç¼ºé¡µ9æ¬¡
1 2 3 4 1 2 5 1 2 3 4 5
1 1 1 4 4 4 5 5 5 3 3 3
  2 2 2 1 1 1 1 1 1 4 4
    3 3 3 2 2 2 2 2 2 2 5
    *   * * * *     * * *

4ä¸ªé¡µæ¡†ï¼šç¼ºé¡µ10æ¬¡ï¼ˆæ›´å¤šï¼ï¼‰
```

### 5.3 æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆLRUï¼‰

**åŸç†**ï¼šæ›¿æ¢æœ€é•¿æ—¶é—´æœªä½¿ç”¨çš„é¡µ

```c
// æ–¹æ¡ˆ1ï¼šæ—¶é—´æˆ³
struct page {
    int frame_num;
    int last_use_time;
};

int lru_replace_timestamp() {
    int oldest_time = INT_MAX;
    int victim = -1;
    
    for (int i = 0; i < capacity; i++) {
        if (pages[i].last_use_time < oldest_time) {
            oldest_time = pages[i].last_use_time;
            victim = i;
        }
    }
    
    return victim;
}

// æ–¹æ¡ˆ2ï¼šé“¾è¡¨
// æœ€è¿‘ä½¿ç”¨çš„æ”¾é“¾è¡¨å¤´ï¼Œæ›¿æ¢æ—¶é€‰é“¾è¡¨å°¾
struct lru_list {
    struct list_head head;
};

void lru_access(int page_num) {
    // ç§»åˆ°é“¾è¡¨å¤´
    list_move(&pages[page_num].list, &lru_list.head);
}

int lru_replace_list() {
    // è¿”å›é“¾è¡¨å°¾
    return list_last_entry(&lru_list.head, struct page, list);
}
```

**æ€§èƒ½**ï¼š
- ç†è®ºä¸Šæ¥è¿‘OPT
- å®ç°å¼€é”€å¤§ï¼ˆæ¯æ¬¡è®¿é—®éƒ½è¦æ›´æ–°ï¼‰

### 5.4 Clockç®—æ³•ï¼ˆè¿‘ä¼¼LRUï¼‰

**åŸç†**ï¼šå¾ªç¯æ‰«æï¼Œç»™ç¬¬äºŒæ¬¡æœºä¼š

```c
struct page_frame {
    int page_num;
    int reference_bit;  // è®¿é—®ä½
};

page_frame frames[CAPACITY];
int clock_hand = 0;

int clock_replace() {
    while (1) {
        if (frames[clock_hand].reference_bit == 0) {
            // æ‰¾åˆ°å—å®³é¡µ
            int victim = clock_hand;
            clock_hand = (clock_hand + 1) % CAPACITY;
            return victim;
        } else {
            // ç»™ç¬¬äºŒæ¬¡æœºä¼š
            frames[clock_hand].reference_bit = 0;
            clock_hand = (clock_hand + 1) % CAPACITY;
        }
    }
}

// é¡µé¢è®¿é—®æ—¶è®¾ç½®è®¿é—®ä½
void page_access(int page_num) {
    for (int i = 0; i < CAPACITY; i++) {
        if (frames[i].page_num == page_num) {
            frames[i].reference_bit = 1;
            break;
        }
    }
}
```

**æ”¹è¿›ï¼šClock-æ”¹è¿›ç®—æ³•**
```c
// è€ƒè™‘è®¿é—®ä½å’Œä¿®æ”¹ä½
// (reference, dirty)
// (0, 0) - æœ€ä½³æ›¿æ¢
// (0, 1) - éœ€è¦å†™å›
// (1, 0) - æœ€è¿‘è®¿é—®
// (1, 1) - æœ€è¿‘è®¿é—®ä¸”ä¿®æ”¹
```

### 5.5 å·¥ä½œé›†ç®—æ³•

**å·¥ä½œé›†**ï¼šæœ€è¿‘Î”ä¸ªæ—¶é—´å•ä½å†…è®¿é—®çš„é¡µé¢é›†åˆ

```c
struct working_set {
    int pages[MAX_PAGES];
    int access_time[MAX_PAGES];
    int size;
};

void update_working_set(int page, int current_time) {
    // ç§»é™¤æ—¶é—´çª—å£å¤–çš„é¡µé¢
    for (int i = 0; i < ws.size; i++) {
        if (current_time - ws.access_time[i] > DELTA) {
            remove_page(i);
        }
    }
    
    // æ·»åŠ æ–°é¡µé¢
    add_page(page, current_time);
}
```

---

## 6. å†™æ—¶å¤åˆ¶ï¼ˆCopy-On-Writeï¼‰

**åŸç†**ï¼šforkæ—¶ä¸å¤åˆ¶å†…å­˜ï¼Œåªæœ‰å†™å…¥æ—¶æ‰å¤åˆ¶

```c
void fork_cow() {
    // 1. å¤åˆ¶é¡µè¡¨
    child->page_table = copy_page_table(parent->page_table);
    
    // 2. æ ‡è®°æ‰€æœ‰é¡µä¸ºåªè¯»
    for (int i = 0; i < NUM_PAGES; i++) {
        parent->page_table[i].writable = 0;
        child->page_table[i].writable = 0;
    }
    
    // 3. å¼•ç”¨è®¡æ•°+1
    for (int i = 0; i < NUM_PAGES; i++) {
        page_ref_count[i]++;
    }
}

void page_fault_handler(unsigned int addr) {
    int page_num = addr >> 12;
    
    if (page_ref_count[page_num] > 1) {
        // å†™æ—¶å¤åˆ¶
        void *new_page = alloc_page();
        memcpy(new_page, frames[page_num], PAGE_SIZE);
        
        page_table[page_num].pfn = get_pfn(new_page);
        page_table[page_num].writable = 1;
        
        page_ref_count[page_num]--;
    } else {
        // åªæœ‰ä¸€ä¸ªå¼•ç”¨ï¼Œç›´æ¥æ”¹ä¸ºå¯å†™
        page_table[page_num].writable = 1;
    }
}
```

**ä¼˜åŠ¿**ï¼š
- forké€Ÿåº¦å¿«
- èŠ‚çœå†…å­˜
- forkåç«‹å³execçš„åœºæ™¯æ•ˆç‡æé«˜

---

## 7. å†…å­˜åˆ†é…

### 7.1 ä¼™ä¼´ç³»ç»Ÿï¼ˆBuddy Systemï¼‰

**åŸç†**ï¼š2çš„å¹‚æ¬¡åˆ†é…ï¼Œç›¸é‚»å—å¯åˆå¹¶

```c
#define MAX_ORDER 11  // æ”¯æŒ2^0åˆ°2^10é¡µ

struct free_area {
    struct list_head free_list;
    int nr_free;
};

struct free_area free_area[MAX_ORDER];

void* buddy_alloc(int order) {
    // 1. æ‰¾åˆ°æ»¡è¶³å¤§å°çš„å—
    for (int i = order; i < MAX_ORDER; i++) {
        if (!list_empty(&free_area[i].free_list)) {
            void *block = list_first_entry(&free_area[i].free_list);
            list_del(&block->list);
            
            // 2. åˆ†è£‚å¤§å—
            while (i > order) {
                i--;
                void *buddy = block + (1 << i) * PAGE_SIZE;
                list_add(&buddy->list, &free_area[i].free_list);
            }
            
            return block;
        }
    }
    
    return NULL;  // å†…å­˜ä¸è¶³
}

void buddy_free(void *block, int order) {
    // å°è¯•åˆå¹¶ä¼™ä¼´
    while (order < MAX_ORDER - 1) {
        void *buddy = get_buddy(block, order);
        
        if (!is_free(buddy, order)) {
            break;  // ä¼™ä¼´ä¸ç©ºé—²
        }
        
        // åˆå¹¶
        list_del(&buddy->list);
        if (buddy < block) {
            block = buddy;
        }
        order++;
    }
    
    // åŠ å…¥ç©ºé—²é“¾è¡¨
    list_add(&block->list, &free_area[order].free_list);
}
```

### 7.2 Slabåˆ†é…å™¨

**åŸç†**ï¼šä¸ºå¸¸ç”¨å¤§å°é¢„åˆ†é…å¯¹è±¡ç¼“å­˜

```c
struct kmem_cache {
    char *name;
    size_t size;
    void (*ctor)(void*);  // æ„é€ å‡½æ•°
    
    struct list_head slabs_full;
    struct list_head slabs_partial;
    struct list_head slabs_free;
};

void* kmem_cache_alloc(struct kmem_cache *cache) {
    // 1. ä¼˜å…ˆä»partial slabåˆ†é…
    if (!list_empty(&cache->slabs_partial)) {
        struct slab *slab = list_first_entry(&cache->slabs_partial);
        void *obj = slab_alloc(slab);
        
        if (slab_full(slab)) {
            list_move(&slab->list, &cache->slabs_full);
        }
        
        return obj;
    }
    
    // 2. ä»free slabåˆ†é…
    if (!list_empty(&cache->slabs_free)) {
        struct slab *slab = list_first_entry(&cache->slabs_free);
        void *obj = slab_alloc(slab);
        list_move(&slab->list, &cache->slabs_partial);
        return obj;
    }
    
    // 3. åˆ†é…æ–°slab
    struct slab *new_slab = alloc_slab(cache);
    return slab_alloc(new_slab);
}
```

---

## 8. å®æˆ˜æ¡ˆä¾‹

### 8.1 æµ‹é‡ç¼ºé¡µç‡

```c
#include <sys/time.h>
#include <sys/resource.h>

void measure_page_faults() {
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
    
    printf("ä¸»ç¼ºé¡µ: %ld\n", usage.ru_majflt);  // éœ€è¦ç£ç›˜I/O
    printf("æ¬¡ç¼ºé¡µ: %ld\n", usage.ru_minflt);  // åªéœ€åˆ†é…ç‰©ç†é¡µ
}
```

### 8.2 mmapå†…å­˜æ˜ å°„

```c
#include <sys/mman.h>

void* ptr = mmap(NULL, size, 
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS,
                -1, 0);

// ä½¿ç”¨å†…å­˜...

munmap(ptr, size);
```

### 8.3 å¤§é¡µé¢ï¼ˆHuge Pagesï¼‰

```bash
# é…ç½®å¤§é¡µé¢ï¼ˆ2MBï¼‰
echo 100 > /proc/sys/vm/nr_hugepages

# æŸ¥çœ‹å¤§é¡µé¢ä½¿ç”¨æƒ…å†µ
cat /proc/meminfo | grep Huge
```

```c
// ä½¿ç”¨å¤§é¡µé¢
void *ptr = mmap(NULL, size,
                PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                -1, 0);
```

**ä¼˜åŠ¿**ï¼š
- å‡å°‘TLBæœªå‘½ä¸­
- å‡å°‘é¡µè¡¨å¤§å°
- é€‚åˆå¤§å†…å­˜åº”ç”¨

---

## 9. å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆéœ€è¦è™šæ‹Ÿå†…å­˜ï¼Ÿ
**A**:
1. è¿›ç¨‹éš”ç¦»å’Œä¿æŠ¤
2. ç®€åŒ–å†…å­˜ç®¡ç†
3. æ”¯æŒè¿›ç¨‹é—´å…±äº«
4. å…è®¸ä½¿ç”¨æ¯”ç‰©ç†å†…å­˜æ›´å¤§çš„åœ°å€ç©ºé—´

### Q2: é¡µé¢å¤§å°å¦‚ä½•é€‰æ‹©ï¼Ÿ
**A**:
- å°é¡µé¢ï¼šå‡å°‘å†…éƒ¨ç¢ç‰‡ï¼Œä½†é¡µè¡¨å¤§
- å¤§é¡µé¢ï¼šå‡å°‘é¡µè¡¨å¤§å°å’ŒTLBæœªå‘½ä¸­ï¼Œä½†å†…éƒ¨ç¢ç‰‡å¤š
- å¸¸ç”¨ï¼š4KBï¼ˆé€šç”¨ï¼‰ï¼Œ2MBï¼ˆå¤§é¡µé¢ï¼‰

### Q3: å¦‚ä½•å‡å°‘ç¼ºé¡µä¸­æ–­ï¼Ÿ
**A**:
1. å¢åŠ ç‰©ç†å†…å­˜
2. ä¼˜åŒ–é¡µé¢ç½®æ¢ç®—æ³•
3. ä½¿ç”¨å±€éƒ¨æ€§åŸç†
4. é¢„å–ç­–ç•¥
5. ä½¿ç”¨å¤§é¡µé¢

### Q4: ä¸ºä»€ä¹ˆforké‚£ä¹ˆå¿«ï¼Ÿ
**A**: å†™æ—¶å¤åˆ¶ï¼åªå¤åˆ¶é¡µè¡¨ï¼Œä¸å¤åˆ¶å®é™…æ•°æ®

---

## å‚è€ƒèµ„æº

- ã€Šæ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿã€‹(CSAPP) - ç¬¬9ç« 
- ã€ŠOperating Systems: Three Easy Piecesã€‹
- Linuxæºç ï¼š`mm/memory.c`, `mm/page_alloc.c`
- Intelæ‰‹å†Œï¼šã€ŠIntel 64 and IA-32 Architectures Software Developer's Manualã€‹

